//------------------------------------------------
//--- 010 Editor v4.0.3 Binary Template
//
//      File: EXE.bt
//   Authors: xSpy, Peter Kankowski, SweetScape Software, mirar
//    E-mail: cdutboy@gmail.com (xSpy)
//   Website: http://smallcode.weblogs.us (Peter Kankowski)
//   Version: 0.9.4
//   Purpose: Parse Windows executable exe, dll, and sys files.
//            Supports 32 and 64 bit.
//  Category: Executable
// File Mask: *.exe,*.dll,*.sys
//  ID Bytes: 4D 5A //MZ
//   History:
//   0.9.4   2023-06-09 SweetScape:    Updated to use template styles.
//   0.9.3   2023-03-28 SweetScape:    Fixed error being shown when Space2 was not created.
//   0.9.2   2022-12-28 R Lagcher:     Updated mapping of Rich id and version on comp.id
//   0.9.1   2022-11-17 G Cazzetta:    Fixed misplacement of sections raw data for out-of-order layouts
//   0.9     2021-09-09 OSchneider:    Added certificate parsing, more read functions
//   0.8     2021-09-09 SweetScape:    Added disassembly to .text section.
//   0.7.6   2021-07-25 ts:            Tiny change to parse timestamp in IMAGE_DEBUG_DIRECTORY
//   0.7.5   2021-07-13 zhentar:       Added debug directory parsing
//   0.7.4   2021-06-18 ts:            Updated IMAGE_MACHINE enum (added ARM64 among others)
//   0.7.3   2021-02-11 Gon Rappaport: Fixed and improved base relocation parsing
//   0.7.2   2019-09-16 gf:            CommentBaseRelocBlock detects more cases.
//   0.7.1   2019-09-02 mirar:         Added mapping of Rich id and version on comp.id
//   0.7     2019-07-10 mirar:         Added Rich header parsing
//   0.6     2019-03-18 Sen Jiang:     Allow NT header to be overlapping with DOS header
//   0.5     2018-04-21 Joshua Dugie:  Added resource section parsing, cleaned up formatting and order,
//                                     also added Resource Directory String parsing
//   0.4     2018-03-08 Rafal Cyran:   Fixed size of IMAGE_EXPORT_DIRECTORY
//   0.3     2016-03-31 T Strazzere:   Fixed issue with IMAGE_IMPORT_DESCRIPTOR
//   0.2     2016-03-10 Yann Le Brech: Added LittleEndian();
//   0.1     2016-02-15 SweetScape Software: Merged changes from PETemplate.bt and EXETemplate2.bt
//                                           and renamed to this file. Added some coloring and rearranged
//                                           for readability. Update header for repository submission.
//   0.0.0.2 2013-01-06 xSpy: Add Parse Reloc.
//   0.0.0.1 2013-01-01 xSpy: Public release.
//
// Recommended reading:
// 1. Bernd Luevelsmeyer. The PE file format
//    http://webster.cs.ucr.edu/Page_TechDocs/pe.txt
// 2. DJ Delorie. MS DOS EXE format
//    http://www.delorie.com/djgpp/doc/exe/
// 3. Iczelion. PE tutorial
//    http://spiff.tripnet.se/~iczelion/tutorials.html
// 4. The Undocumented Microsoft "Rich" Header
//    http://bytepointer.com/articles/the_microsoft_rich_header.htm
//------------------------------------------------
RequiresVersion( 14 );

typedef QWORD ULONGLONG;    //fix ULONGLONG


/**** DOS AND NT HEADER STRUCTURES ****/
typedef struct
{
    WORD   MZSignature              <comment="IMAGE_DOS_SIGNATURE = 0x5A4D",format=hex,style=sHeading1Accent>;
    WORD   UsedBytesInTheLastPage   <comment="Bytes on last page of file">;
    WORD   FileSizeInPages          <comment="Pages in file">;
    WORD   NumberOfRelocationItems  <comment="Relocations">;
    WORD   HeaderSizeInParagraphs   <comment="Size of header in paragraphs">;
    WORD   MinimumExtraParagraphs   <comment="Minimum extra paragraphs needed">;
    WORD   MaximumExtraParagraphs   <comment="Maximum extra paragraphs needed">;
    WORD   InitialRelativeSS        <comment="Initial (relative) SS value">;
    WORD   InitialSP                <comment="Initial SP value">;
    WORD   Checksum                 <comment="Checksum">;
    WORD   InitialIP                <comment="Initial IP value">;
    WORD   InitialRelativeCS        <comment="Initial (relative) CS value">;
    WORD   AddressOfRelocationTable <comment="File address of relocation table">;
    WORD   OverlayNumber            <comment="Overlay number">;
    WORD   Reserved[4]              <comment="Reserved words">;
    WORD   OEMid                    <comment="OEM identifier (for OEMinfo)">;
    WORD   OEMinfo                  <comment="OEM information; OEMid specific">;
    WORD   Reserved2[10]            <comment="Reserved words">;
    LONG   AddressOfNewExeHeader    <comment="NtHeader Offset",format=hex>;
} IMAGE_DOS_HEADER <style=sHeading1>;

typedef struct (int Entries)
{
    DWORD StartMarker               <comment="Rich header start marker",format=hex>;
    DWORD Padding[3]                <comment="padding",hidden=true>;

    struct RICH_HEADER_ENTRY {      
        DWORD IdVersion             <read=ReadRichEntryIdVersion>;
        DWORD Count                 <read=ReadRichEntryCount>;
    } Entry[Entries]                <comment="Rich header entries">;

    DWORD EndMarker                 <comment="Rich header end marker",format=hex>;
    DWORD XorKey                    <comment="Rich xor encoding key",format=hex>;
} RICH_HEADER <style=sSection1>;

typedef struct
{
    local ULONG RichEnd = 0;
    local ULONG ea;
    local DWORD dw;
    for ( ea = FTell(); ea < DosHeader.AddressOfNewExeHeader; ea += 4 )
    {
        dw = ReadUInt64(ea);
        if(dw == 0x68636952u) // Rich end marker "Rich"
        {
            RichEnd = ea;
            break;
        }
    }
    if (RichEnd != 0) {
        local DWORD XorKey;
        local DWORD Decoded;
        local DWORD RichStart;
        local int Entries;
        XorKey = ReadUInt64(RichEnd + 4);
        for (ea = ea - 4; ea >= FTell(); ea -= 4)
        {
            Decoded = ReadUInt64(ea);
            Decoded ^= XorKey;
            if (Decoded == 0x536E6144) // Rich start marker "DanS"
            {
                RichStart = ea;
                break;
            }
        }
        UCHAR Data[RichStart - sizeof(IMAGE_DOS_HEADER)] <comment="Space between DOS header and NT header">;  
        Entries = (RichEnd - RichStart - 16) / 8;
        RICH_HEADER RichHeader(Entries);
    }
    else if (DosHeader.AddressOfNewExeHeader > sizeof(IMAGE_DOS_HEADER))
    {
        UCHAR Data[DosHeader.AddressOfNewExeHeader - sizeof(IMAGE_DOS_HEADER)] <comment="Space between DOS header and NT header">;
    }
    Printf("Space between DOS header and NT header is %d bytes\n", DosHeader.AddressOfNewExeHeader - sizeof(IMAGE_DOS_HEADER));
} IMAGE_DOS_STUB <style=sHeading2>;

typedef enum<WORD>
{
    IMAGE_MACHINE_UNKNOWN  = 0,
    I386      = 0x014c,  // Intel 386 or later processors and compatible processors
    R3000     = 0x0162,  // MIPS little-endian, 0x160 big-endian
    R4000     = 0x0166,  // MIPS little-endian
    R10000    = 0x0168,  // MIPS little-endian
    WCEMIPSV2 = 0x0169,  // MIPS little-endian WCE v2
    ALPHA     = 0x0184,  // Alpha_AXP
    SH3       = 0x01a2,  // Hitachi SH3
    SH3DSP    = 0x01a3,  // Hitachi SH3 DSP
    SH3E      = 0x01a4,  // Hitachi SH3E little-endian
    SH4       = 0x01a6,  // Hitachi SH4
    SH5       = 0x01a8,  // Hitachi SH5
    ARM       = 0x01c0,  // ARM little-endian
    THUMB     = 0x01c2,  // Thumb
    ARMNT     = 0x01c4,  // Arm Thumb-2 little-endian
    AM33      = 0x01d3,  // Matsushita AM33
    POWERPC   = 0x01f0,  // Power PC little endian
    POWERPCFP = 0x01f1,  // Power PC with floating point support
    IA64      = 0x0200,  // Intel Itanium processor family
    MIPS16    = 0x0266,  // MIPS16
    ALPHA64   = 0x0284,  // ALPHA64
    MIPSFPU   = 0x0366,  // MIPS with FPU
    MIPSFPU16 = 0x0466,  // MIPS16 with FPU
    TRICORE   = 0x0520,  // Infineon
    CEF       = 0x0CEF,
    EBC       = 0x0EBC,  // EFI Byte Code
    RISCV32   = 0x5032,  // RISC-V 32-bit address space
    RISCV64   = 0x5064,  // RISC-V 64-bit address space
    RISCV128  = 0x5128,  // RISC-V 128-bit address space
    AMD64     = 0x8664,  // x64
    M32R      = 0x9041,  // Mitsubishi M32R little-endian
    ARM64     = 0xAA64,  // ARM64 little-endian
    CEE       = 0xC0EE
} IMAGE_MACHINE <comment="WORD">;

// Characteristics
typedef struct
{
    WORD IMAGE_FILE_RELOCS_STRIPPED:1           <comment="0x0001  Relocation info stripped from file">;
    WORD IMAGE_FILE_EXECUTABLE_IMAGE:1          <comment="0x0002  File is executable">;
    WORD IMAGE_FILE_LINE_NUMS_STRIPPED:1        <comment="0x0004  Line nunbers stripped from file">;
    WORD IMAGE_FILE_LOCAL_SYMS_STRIPPED:1       <comment="0x0008  Local symbols stripped from file">;
    WORD IMAGE_FILE_AGGRESIVE_WS_TRIM:1         <comment="0x0010  Agressively trim working set">;
    WORD IMAGE_FILE_LARGE_ADDRESS_AWARE:1       <comment="0x0020  App can handle >2gb addresses">;
    WORD                               :1       <comment="0x0040  Reserved",hidden=true>;
    WORD IMAGE_FILE_BYTES_REVERSED_LO:1         <comment="0x0080  Bytes of machine word are reversed">;
    WORD IMAGE_FILE_32BIT_MACHINE:1             <comment="0x0100  32 bit word machine">;
    WORD IMAGE_FILE_DEBUG_STRIPPED:1            <comment="0x0200  Debugging info stripped from file in .DBG file">;
    WORD IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP:1   <comment="0x0400  If Image is on removable media, copy and run from the swap file">;
    WORD IMAGE_FILE_NET_RUN_FROM_SWAP:1         <comment="0x0800  If Image is on Net, copy and run from the swap file">;
    WORD IMAGE_FILE_SYSTEM:1                    <comment="0x1000  System File">;
    WORD IMAGE_FILE_DLL:1                       <comment="0x2000  File is a DLL">;
    WORD IMAGE_FILE_UP_SYSTEM_ONLY:1            <comment="0x4000  File should only be run on a UP machine">;
    WORD IMAGE_FILE_BYTES_REVERSED_HI:1         <comment="0x8000  Bytes of machine word are reversed">;
} FILE_CHARACTERISTICS <comment="WORD">;

typedef struct
{
    IMAGE_MACHINE    Machine                    <fgcolor=cPurple,format=hex,comment="WORD">;
    WORD    NumberOfSections                    <fgcolor=cBlue,comment="Section num">;
    time_t  TimeDateStamp                       <format=hex,comment="DWORD,from 01/01/1970 12:00 AM">;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    FILE_CHARACTERISTICS   Characteristics      <comment="WORD">;
} IMAGE_FILE_HEADER;

typedef struct
{
    DWORD   VirtualAddress  <format=hex,comment=CommentRVA2FOA>;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY <read=ReadImageDataDirectory>;

typedef struct
{
    local int len = NtHeader.OptionalHeader.NumberOfRvaAndSizes;
    if (len > 16)
    {
        len = 16;
    }
    if (len > 0)  IMAGE_DATA_DIRECTORY  Export                              <comment="IMAGE_DIRECTORY_ENTRY_EXPORT">;
    if (len > 1)  IMAGE_DATA_DIRECTORY  Import                              <comment="IMAGE_DIRECTORY_ENTRY_IMPORT",fgcolor=cPurple>;
    if (len > 2)  IMAGE_DATA_DIRECTORY  Resource                            <comment="IMAGE_DIRECTORY_ENTRY_RESOURCE">;
    if (len > 3)  IMAGE_DATA_DIRECTORY  Exception                           <comment="IMAGE_DIRECTORY_ENTRY_EXCEPTION">;
    if (len > 4)  IMAGE_DATA_DIRECTORY  Security                            <comment="IMAGE_DIRECTORY_ENTRY_SECURITY">;
    if (len > 5)  IMAGE_DATA_DIRECTORY  BaseRelocationTable                 <comment="IMAGE_DIRECTORY_ENTRY_BASERELOC",fgcolor=cPurple>;
    if (len > 6)  IMAGE_DATA_DIRECTORY  DebugDirectory                      <comment="IMAGE_DIRECTORY_ENTRY_DEBUG">;
    if (len > 7)  IMAGE_DATA_DIRECTORY  CopyrightOrArchitectureSpecificData <comment="IMAGE_DIRECTORY_ENTRY_ARCHITECTURE">;
    if (len > 8)  IMAGE_DATA_DIRECTORY  GlobalPtr                           <comment="IMAGE_DIRECTORY_ENTRY_GLOBALPTR">;
    if (len > 9)  IMAGE_DATA_DIRECTORY  TLSDirectory                        <comment="IMAGE_DIRECTORY_ENTRY_TLS">;
    if (len > 10) IMAGE_DATA_DIRECTORY  LoadConfigurationDirectory          <comment="IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG">;
    if (len > 11) IMAGE_DATA_DIRECTORY  BoundImportDirectory                <comment="IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT">;
    if (len > 12) IMAGE_DATA_DIRECTORY  ImportAddressTable                  <comment="IMAGE_DIRECTORY_ENTRY_IAT",fgcolor=cPurple>;
    if (len > 13) IMAGE_DATA_DIRECTORY  DelayLoadImportDescriptors          <comment="IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT">;
    if (len > 14) IMAGE_DATA_DIRECTORY  COMRuntimedescriptor                <comment="IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR">;
    if (len > 15) IMAGE_DATA_DIRECTORY  Reserved                            <comment="System Reserved">;
} IMAGE_DATA_DIRECTORY_ARRAY;

typedef enum<WORD>
{
    IMAGE_SUBSYSTEM_UNKNOWN  = 0,  // Unknown subsystem
    NATIVE                   = 1,  // Image doesn't require a subsystem
    WINDOWS_GUI              = 2,  // Image runs in the Windows GUI subsystem
    WINDOWS_CUI              = 3,  // Image runs in the Windows character subsystem
    OS2_CUI                  = 5,  // image runs in the OS/2 character subsystem
    POSIX_CUI                = 7,  // image runs in the Posix character subsystem
    NATIVE_WINDOWS           = 8,  // image is a native Win9x driver
    WINDOWS_CE_GUI           = 9,  // Image runs in the Windows CE subsystem
    EFI_APPLICATION          = 10,
    EFI_BOOT_SERVICE_DRIVER  = 11,
    EFI_RUNTIME_DRIVER       = 12,
    EFI_ROM                  = 13,
    XBOX                     = 14,
    WINDOWS_BOOT_APPLICATION = 16
} IMAGE_SUBSYSTEM <comment="WORD">;

typedef struct
{
    WORD IMAGE_LIBRARY_PROCESS_INIT                     :1 <comment="0x0001 Reserved">;
    WORD IMAGE_LIBRARY_PROCESS_TERM                     :1 <comment="0x0002 Reserved">;
    WORD IMAGE_LIBRARY_THREAD_INIT                      :1 <comment="0x0004 Reserved">;
    WORD IMAGE_LIBRARY_THREAD_TERM                      :1 <comment="0x0008 Reserved">;
    WORD                                                :1 <comment="0x0010",hidden=true>;
    WORD IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       :1 <comment="0x0020">;
    WORD IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          :1 <comment="0x0040">;
    WORD IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       :1 <comment="0x0080">;
    WORD IMAGE_DLLCHARACTERISTICS_NX_COMPAT             :1 <comment="0x0100">;
    WORD IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          :1 <comment="0x0200">;
    WORD IMAGE_DLLCHARACTERISTICS_NO_SEH                :1 <comment="0x0400">;
    WORD IMAGE_DLLCHARACTERISTICS_NO_BIND               :1 <comment="0x0800">;
    WORD                                                :1 <comment="0x1000",hidden=true>;
    WORD IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            :1 <comment="0x2000">;
    WORD                                                :1 <comment="0x4000",hidden=true>;
    WORD IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE :1 <comment="0x8000">;
} DLL_CHARACTERISTICS <comment="WORD", read=ReadDllCharacteristics>;

typedef enum<WORD>
{
    PE32 = 0x10b,
    PE64 = 0x20b,
    ROM  = 0x107
} OPTIONAL_MAGIC <comment="WORD">;

typedef struct
{
    OPTIONAL_MAGIC Magic        <format=hex>;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode          <format=hex>;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint <format=hex,comment=CommentRVA2FOA,fgcolor=cPurple>;
    DWORD   BaseOfCode          <format=hex,comment=CommentRVA2FOA>;
    DWORD   BaseOfData          <format=hex,comment=CommentRVA2FOA>;
    DWORD   ImageBase           <format=hex>;
    DWORD   SectionAlignment    <format=hex>;
    DWORD   FileAlignment       <format=hex>;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage         <format=hex>;
    DWORD   SizeOfHeaders       <format=hex>;
    DWORD   CheckSum            <format=hex>;
    IMAGE_SUBSYSTEM Subsystem;
    DLL_CHARACTERISTICS DllCharacteristics;
    DWORD   SizeOfStackReserve  <format=hex>;
    DWORD   SizeOfStackCommit   <format=hex>;
    DWORD   SizeOfHeapReserve   <format=hex>;
    DWORD   SizeOfHeapCommit    <format=hex>;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY_ARRAY DataDirArray;
} IMAGE_OPTIONAL_HEADER32;

typedef struct
{
    OPTIONAL_MAGIC Magic            <format=hex>;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint <format=hex,comment=CommentRVA2FOA>;
    DWORD       BaseOfCode          <format=hex>;
    ULONGLONG   ImageBase           <format=hex>;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage         <format=hex>;
    DWORD       SizeOfHeaders       <format=hex>;
    DWORD       CheckSum            <format=hex>;
    IMAGE_SUBSYSTEM Subsystem;
    DLL_CHARACTERISTICS DllCharacteristics;
    ULONGLONG   SizeOfStackReserve  <format=hex>;
    ULONGLONG   SizeOfStackCommit   <format=hex>;
    ULONGLONG   SizeOfHeapReserve   <format=hex>;
    ULONGLONG   SizeOfHeapCommit    <format=hex>;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY_ARRAY DataDirArray;
} IMAGE_OPTIONAL_HEADER64;

typedef struct
{
    DWORD Signature <format=hex,comment="IMAGE_NT_SIGNATURE = 0x00004550">;
    IMAGE_FILE_HEADER FileHeader;

    local WORD OptionalHeaderMagic = ReadShort(FTell());

    if (0x10b == OptionalHeaderMagic)
    {
        IMAGE_OPTIONAL_HEADER32 OptionalHeader;
    }
    else if (0x20b == OptionalHeaderMagic)
    {
        IMAGE_OPTIONAL_HEADER64 OptionalHeader;
    }
    else
    {
        Printf("Invalid Optional header magic %x.\n", OptionalHeaderMagic);
        return 1;
    }
} IMAGE_NT_HEADERS <size=CalcImageNtHeadersSize, style=sHeading3>;


/**** GENERIC SECTION HEADERS ****/
typedef struct
{
    ULONG IMAGE_SCN_TYPE_DSECT:1                 <comment="0x00000001 Reserved",hidden=true>;
    ULONG IMAGE_SCN_TYPE_NOLOAD:1                <comment="0x00000002 Reserved",hidden=true>;
    ULONG IMAGE_SCN_TYPE_GROUP:1                 <comment="0x00000004 Reserved",hidden=true>;
    ULONG IMAGE_SCN_TYPE_NO_PAD:1                <comment="0x00000008 Reserved">;
    ULONG IMAGE_SCN_TYPE_COPY:1                  <comment="0x00000010 Reserved",hidden=true>;

    ULONG IMAGE_SCN_CNT_CODE:1                   <comment="0x00000020 Section contains code">;
    ULONG IMAGE_SCN_CNT_INITIALIZED_DATA:1       <comment="0x00000040 Section contains initialized data">;
    ULONG IMAGE_SCN_CNT_UNINITIALIZED_DATA:1     <comment="0x00000080 Section contains uninitialized data">;

    ULONG IMAGE_SCN_LNK_OTHER:1                  <comment="0x00000100 Reserved">;
    ULONG IMAGE_SCN_LNK_INFO:1                   <comment="0x00000200 Section contains comments or some other type of information">;
    ULONG IMAGE_SCN_TYPE_OVER:1                  <comment="0x00000400 Reserved",hidden=true>;
    ULONG IMAGE_SCN_LNK_REMOVE:1                 <comment="0x00000800 Section contents will not become part of image">;
    ULONG IMAGE_SCN_LNK_COMDAT:1                 <comment="0x00001000 Section contents comdat">;
    ULONG                      :1                <comment="0x00002000 Reserved">;
    ULONG IMAGE_SCN_NO_DEFER_SPEC_EXC:1          <comment="0x00004000 Reset speculative exceptions handling bits in the TLB entries for this section.",hidden=true>;
    ULONG IMAGE_SCN_GPREL:1                      <comment="0x00008000 Section content can be accessed relative to GP">;
    ULONG IMAGE_SCN_MEM_SYSHEAP:1                <comment="0x00010000 Obsolete",hidden=true>;
    ULONG IMAGE_SCN_MEM_16BIT:1                  <comment="0x00020000">;
    ULONG IMAGE_SCN_MEM_LOCKED:1                 <comment="0x00040000 ">;
    ULONG IMAGE_SCN_MEM_PRELOAD:1                <comment="0x00080000">;

    ULONG IMAGE_SCN_ALIGN_1BYTES:1               <comment="0x00100000">;
    ULONG IMAGE_SCN_ALIGN_2BYTES:1               <comment="0x00200000">;
    ULONG IMAGE_SCN_ALIGN_8BYTES:1               <comment="0x00400000">;
    ULONG IMAGE_SCN_ALIGN_128BYTES:1             <comment="0x00800000">;

    ULONG IMAGE_SCN_LNK_NRELOC_OVFL:1            <comment="0x01000000 Section contains extended relocations">;
    ULONG IMAGE_SCN_MEM_DISCARDABLE:1            <comment="0x02000000 Section can be discarded.">;
    ULONG IMAGE_SCN_MEM_NOT_CACHED:1             <comment="0x04000000 Section is not cachable">;
    ULONG IMAGE_SCN_MEM_NOT_PAGED:1              <comment="0x08000000 Section is not pageable.">;
    ULONG IMAGE_SCN_MEM_SHARED:1                 <comment="0x10000000 Section is shareable">;
    ULONG IMAGE_SCN_MEM_EXECUTE:1                <comment="0x20000000 Section is executable">;
    ULONG IMAGE_SCN_MEM_READ:1                   <comment="0x40000000 Section is readable">;
    ULONG IMAGE_SCN_MEM_WRITE:1                  <comment="0x80000000 Section is writeable">;
} SECTION_CHARACTERISTICS;

typedef struct
{
    BYTE    Name[8] <comment="can end without zero", style=sHeading4Accent>;
    union
    {
        DWORD PhysicalAddress;
        DWORD VirtualSize;
    } Misc;
    DWORD   VirtualAddress          <format=hex>;
    DWORD   SizeOfRawData           <format=hex>;
    DWORD   PointerToRawData        <format=hex>;
    DWORD   PointerToRelocations    <format=hex>;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    SECTION_CHARACTERISTICS Characteristics <format=hex>;
} IMAGE_SECTION_HEADER <read=ReadImageSectionHeader, style=sHeading4>;

typedef struct (IMAGE_SECTION_HEADER& SecHeader)
{
    local string sSecName = SecHeader.Name;
    if( sSecName == ".text" )
    {
        // Disassemble .text section
        if( NtHeader.FileHeader.Machine == AMD64 )
            DisasmSetMode( DISASM_X86_64 );
        else
            DisasmSetMode( DISASM_X86_32 );
        Opcode opcode[SecHeader.SizeOfRawData];
    }
    else
        UCHAR Data[SecHeader.SizeOfRawData];
} IMAGE_SECTION_DATA <read=ReadSectionData, style=sData>;


/**** SECTION-SPECIFIC STRUCTURES ****/
typedef struct (int nNameLen)
{
    WORD    Hint;
    BYTE    Name[nNameLen];
} IMAGE_IMPORT_BY_NAME <comment=CommentImageImportByName>;

typedef struct
{
    local int   nNameIndex=0;
    local ULONG ulThrunk=0;
    local int   nNameLen=0;
    local string sDllName="";
    local ULONG ulOriginalFirstThunkFOA=0;

    union
    {
        ULONG   Characteristics;
        ULONG   OriginalFirstThunk <format=hex,comment=CommentRVA2FOA>;
    } DUMMYUNIONNAME <style=sSection2Accent>;

    ULONG   TimeDateStamp   <comment="0 if not bound">;
    ULONG   ForwarderChain  <comment="-1 if no forwarders">;
    ULONG   Name        <format=hex,comment=CommentRVAString>;
    ULONG   FirstThunk  <format=hex,comment=CommentRVA2FOA>;


    ulOriginalFirstThunkFOA = RVA2FOA(DUMMYUNIONNAME.OriginalFirstThunk);
    if (!(0x20b == NtHeader.OptionalHeader.Magic))
    {
        nNameIndex =0;

        local long og_position = 0;
        while (1)
        {
            ulThrunk = ReadUInt(ulOriginalFirstThunkFOA + 4 * nNameIndex);
            if (0 == ulThrunk)
            {
                break;
            }

            if (!(ulThrunk & 0x80000000))
            {
                nNameLen = Strlen(ReadString(RVA2FOA(ulThrunk) + sizeof(WORD)));
                if (0 != nNameLen)
                {
                    // This appears to not be continuous, so we need to ensure that we
                    // fall back to the original position otherwise the structs will
                    // not finish being created
                    og_position = FTell();
                    FSeek(RVA2FOA(ulThrunk));
                    IMAGE_IMPORT_BY_NAME ImportByName(nNameLen + 1)<open=false>;
                    FSeek(og_position);
                }
            }
            nNameIndex++;
        }
    }
} IMAGE_IMPORT_DESCRIPTOR <read=ReadImageImportDescriptor, style=sSection2>;

typedef struct (string sExportFuncName, ULONG ulDestRVA, string sJmpName)
{
    local ULONG ulLocalDestRVA = ulDestRVA;
    local string sLocalJmpName = sJmpName;

    char Function[Strlen(sExportFuncName) + 1];
} IMAGE_EXPORT_BY_NAME <read=ReadExportByName,comment=CommentExportByName>;

typedef struct
{
    DWORD   Characteristics;
    time_t  TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name <format=hex,comment=CommentRVAString>;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions      <format=hex,comment=CommentRVA2FOA>;    // RVA from base of image
    DWORD   AddressOfNames          <format=hex,comment=CommentRVA2FOA>;    // RVA from base of image
    DWORD   AddressOfNameOrdinals   <format=hex,comment=CommentRVA2FOA>;    // RVA from base of image

    local int   nIndex          = 0;
    local ULONG NameArrayFOA    = 0;
    local ULONG OrdinalArrayFOA = 0;
    local ULONG FuncArrayFOA    = 0;
    local ULONG ulNameRVA       = 0;
    local ULONG ulNameFOA       = 0;
    local ULONG ulFuncRVA       = 0;
    local WORD  wOrdinal        = 0;

    local string sExportName    = "";
    local string sJmpName       = "";

    local ULONG ulCurPos = FTell();
    local ULONG ulEndPos = ulCurPos;

    // List Export names.
    NameArrayFOA    = RVA2FOA(ExportDir.AddressOfNames);
    OrdinalArrayFOA = RVA2FOA(ExportDir.AddressOfNameOrdinals);
    FuncArrayFOA    = RVA2FOA(ExportDir.AddressOfFunctions);

    for (nIndex = 0; nIndex < ExportDir.NumberOfNames; nIndex++)
    {
        ulNameRVA   = ReadUInt(NameArrayFOA + nIndex*sizeof(ULONG));
        ulNameFOA   = RVA2FOA(ulNameRVA);
        sExportName = ReadString(ulNameFOA);

        if (0 != Strlen(sExportName))
        {
            wOrdinal  = ReadUShort(OrdinalArrayFOA + nIndex*sizeof(USHORT));
            ulFuncRVA = ReadUInt(FuncArrayFOA + wOrdinal* sizeof(ULONG) ); //GetRVA

            if ((ulFuncRVA > NtHeader.OptionalHeader.DataDirArray.Export.VirtualAddress) && \
                (ulFuncRVA < NtHeader.OptionalHeader.DataDirArray.Export.VirtualAddress + NtHeader.OptionalHeader.DataDirArray.Export.Size))
            {
                // is a jmp
                sJmpName = ReadString( RVA2FOA(ulFuncRVA) );
                FSeek(ulNameFOA);
                IMAGE_EXPORT_BY_NAME ExportByName(sExportName,ulFuncRVA,sJmpName);
            }
            else
            {
                // normal
                sJmpName = "";
                FSeek(ulNameFOA);
                IMAGE_EXPORT_BY_NAME ExportByName(sExportName,ulFuncRVA,sJmpName);
            }
        }

        ulCurPos = FTell();

        if (ulEndPos < ulCurPos)
        {
            ulEndPos = ulCurPos;
        }
    }

    FSeek(ulEndPos);
} IMAGE_EXPORT_DIRECTORY <comment=CommentExportDirectory>;

typedef struct
{
    WORD Length;
    if (Length > 0)
    {
        BYTE String[Length*2];
    }
} pascal_wstring_t <optimize=false>;

typedef pascal_wstring_t RESOURCE_DIRECTORY_STRING;

typedef struct
{
    RESOURCE_DIRECTORY_STRING Strings[16] <optimize=false,comment=CommentResourceDirectoryString>;
} RESOURCE_DIRECTORY_STRINGS <optimize=false>;

typedef struct
{
    local int originalPos;

    DWORD DataRVA <format=hex>;
    DWORD DataSize;
    DWORD CodePage;
    DWORD Reserved;

    originalPos = FTell();
    FSeek(RVA2FOA(DataRVA));
    if (!IsResourceDirectoryString(this))
    {
        UCHAR Data[DataSize];
    }
    else
    {
        RESOURCE_DIRECTORY_STRINGS ResourceDirectoryStrings;
    }
    FSeek(originalPos);
} RESOURCE_DATA_ENTRY <optimize=false>;

typedef struct (int isNameEntry, DWORD level)
{
    local int IsNameEntry = 0;
    local int originalPos;
    local DWORD Level;
    Level = level;
    IsNameEntry = isNameEntry;
    if (IsNameEntry > 0)
    {
        DWORD NameOffset <comment=CommentResourceNameOffset,format=hex>;
    }
    else
    {
        DWORD IntegerID <comment=CommentIntegerID,format=decimal>;
    }

    local DWORD NextDWORD = ReadInt();
    if (NextDWORD & 0x80000000)
    {
        DWORD SubdirectoryOffset <format=hex>;
        local DWORD dwMaskedOffset;
        dwMaskedOffset = SubdirectoryOffset & 0x7fffffff;
        originalPos = FTell();
        FSeek(RVA2FOA(NtHeader.OptionalHeader.DataDirArray.Resource.VirtualAddress + dwMaskedOffset));
        struct RESOURCE_DIRECTORY_TABLE RsourceDirectoryTable(Level+1);
        FSeek(originalPos);
    }
    else
    {
        DWORD DataEntryOffset <format=hex>;
        originalPos = FTell();
        FSeek(RVA2FOA(NtHeader.OptionalHeader.DataDirArray.Resource.VirtualAddress + DataEntryOffset));
        RESOURCE_DATA_ENTRY ResourceDataEntry;
        FSeek(originalPos);
    }
} RESOURCE_DIRECTORY_ENTRY <optimize=false>;

typedef struct (DWORD level)
{
    local DWORD Level;
    
    DWORD   Characteristics <comment="Reserved, currently 0">;
    time_t  TimeDateStamp;
    WORD    MajorVersion        <format=decimal>;
    WORD    MinorVersion        <format=decimal>;
    WORD    NumberOfNameEntries <format=decimal>;
    WORD    NumberOfIDEntries   <format=decimal>;

    Level = level;
    if (NumberOfNameEntries > 0)
    {
        RESOURCE_DIRECTORY_ENTRY NameEntries(1, Level)[NumberOfNameEntries] <optimize=false>;
    }
    if (NumberOfIDEntries > 0)
    {
        RESOURCE_DIRECTORY_ENTRY IDEntries(0, Level)[NumberOfIDEntries] <optimize=false>;
    }
} RESOURCE_DIRECTORY_TABLE <comment=CommentResourceDirectoryTable,optimize=false,style=sSection4>;

typedef struct (DWORD size)
{
    DWORD dwLength;
    WORD wRevision <read=ReadWinCertRevision>;
    WORD wCertificateType <read=ReadWinCertCertificateType>;
    BYTE bCertificate[size - 8];
} WIN_CERTIFICATE <style=sSection3>;

typedef enum<WORD>
{
    IMAGE_REL_BASED_ABSOLUTE = 0,
    IMAGE_REL_BASED_HIGH,
    IMAGE_REL_BASED_LOW,
    IMAGE_REL_BASED_HIGHLOW,
    IMAGE_REL_BASED_HIGHADJ,
    IMAGE_REL_BASED_MACHINE_SPECIFIC_5,
    IMAGE_REL_BASED_RESERVED,
    IMAGE_REL_BASED_MACHINE_SPECIFIC_7,
    IMAGE_REL_BASED_MACHINE_SPECIFIC_8,
    IMAGE_REL_BASED_MACHINE_SPECIFIC_9,
    IMAGE_REL_BASED_DIR64
} BASE_RELOCATION_TYPE;

typedef struct
{
    WORD                 Offset : 12; 
    BASE_RELOCATION_TYPE Type   : 4;
} BASE_RELOCATION_BLOCK;

typedef struct
{
    DWORD   VirtualAddress <format=hex,comment=CommentRVA2FOA>;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];

    local ULONG ulBlockNum=0;

    ulBlockNum = (SizeOfBlock - 8)/2;
    BASE_RELOCATION_BLOCK Block[ulBlockNum] <comment=CommentBaseRelocBlock>;

} IMAGE_BASE_RELOCATION <comment=CommentImageBaseRelocation>;

typedef struct (DWORD cbRelocDirectory)
{
    local ULONG ulRelocNum=0;

    while ((FTell() - startof(this)) < cbRelocDirectory)
    {
        IMAGE_BASE_RELOCATION BaseReloc;
        ulRelocNum++;
    }
} BASE_RELOCATION_TABLE <comment=CommentBaseRelocationTable>;

typedef struct
{
    DWORD  DataType;
    DWORD  Length;
    DWORD  Reserved;
    string DbgFileName;
} IMAGE_DEBUG_MISC;

typedef enum<DWORD>
{
    COFF = 1,
    CODEVIEW = 2,
    FPO = 3,
    MISC = 4,
    EXCEPTION,
    FIXUP,
    OMAP_TO_SRC,
    OMAP_FROM_SRC,
    BORLAND,
    RESERVED10,
    CLSID,
    VC_FEATURE,
    POGO,
    ILTCG,
    MPX,
    REPRO
} IMAGE_DEBUG_TYPE;

typedef struct
{
    BYTE CvSignature[4];
    if(CvSignature == "RSDS")
    {
        GUID RsDsSignature;
        DWORD Age;
    }
    else if (CvSignature == "NB10")
    {
        DWORD Offset; //not actually used
        DWORD Nb10Signature <format=hex>;
        DWORD Age;
    }

} CV_INFO;

typedef struct 
{
    DWORD   Characteristics;
    time_t  TimeDateStamp    <format=hex>;
    WORD    MajorVersion     <format=decimal>;
    WORD    MinorVersion     <format=decimal>;
    IMAGE_DEBUG_TYPE Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData <format=hex>;
    DWORD   PointerToRawData <format=hex>;

    FSeek(PointerToRawData);
    switch(Type)
    {
        case 2:
            CV_INFO CodeViewInfo;
            break;
        case 4:
            IMAGE_DEBUG_MISC DebugMisc;
            break;
    }
} IMAGE_DEBUG_DIRECTORY <size=0x1C>;

/**** PARSING UTILITY FUNCTIONS ****/

// IMAGE_DIRECTORY_ENTRY_EXPORT 0
void ParseEAT(void)
{
    if ( (NtHeader.OptionalHeader.DataDirArray.Export.VirtualAddress != 0) && (NtHeader.OptionalHeader.DataDirArray.Export.Size != 0) )
    {
        local ULONG ulExportFOA= RVA2FOA(NtHeader.OptionalHeader.DataDirArray.Export.VirtualAddress);
        FSeek(ulExportFOA);
        IMAGE_EXPORT_DIRECTORY ExportDir;
    }
}

// IMAGE_DIRECTORY_ENTRY_IMPORT 1
void ParseIAT()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.Import.VirtualAddress != 0) && (NtHeader.OptionalHeader.DataDirArray.Import.Size != 0) )
    {
        local ULONG ulImportFOA = RVA2FOA(NtHeader.OptionalHeader.DataDirArray.Import.VirtualAddress);    //Import
        local ULONG ulOriginalFirstThunk=0;
        local ULONG ulOriginalFirstThunkFOA=0;
        local int   nImportIndex=0;

        FSeek(ulImportFOA);
        while (1)
        {
            ulOriginalFirstThunk = ReadUInt(ulImportFOA + 0x14*nImportIndex );
            if (0 == ulOriginalFirstThunk)
            {
                break;
            }
            FSeek(ulImportFOA + 0x14*nImportIndex);
            IMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
            nImportIndex++;
        }
    }
}

// IMAGE_DIRECTORY_ENTRY_RESOURCE
void ParseResource()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.Resource.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.Resource.Size == 0) )
    {
       return;
    }
    FSeek(RVA2FOA(NtHeader.OptionalHeader.DataDirArray.Resource.VirtualAddress));
    RESOURCE_DIRECTORY_TABLE ResourceDirectoryTable(1);
}

// IMAGE_DIRECTORY_ENTRY_EXCEPTION
void ParseException()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.Exception.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.Exception.Size == 0) )
    {
       return;
    }
    //FixMe
}

// IMAGE_DIRECTORY_ENTRY_SECURITY
void ParseSecurity()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.Security.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.Security.Size == 0) )
    {
       return;
    }
    // NB: this doesn't seem to be an RVA but an actual offset. Likely because
    // the certificate most often resides outside the "image" (as loaded) in the
    // overlay
    FSeek(NtHeader.OptionalHeader.DataDirArray.Security.VirtualAddress);
    WIN_CERTIFICATE WinCertificate(NtHeader.OptionalHeader.DataDirArray.Security.Size);
}

// IMAGE_DIRECTORY_ENTRY_BASERELOC
void ParseBaseReloc()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.BaseRelocationTable.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.BaseRelocationTable.Size == 0) )
    {
       return;
    }
    FSeek( RVA2FOA(NtHeader.OptionalHeader.DataDirArray.BaseRelocationTable.VirtualAddress) );
    BASE_RELOCATION_TABLE RelocTable(NtHeader.OptionalHeader.DataDirArray.BaseRelocationTable.Size);
}

// IMAGE_DIRECTORY_ENTRY_DEBUG
void ParseDebug()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.DebugDirectory.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DebugDirectory.Size == 0) )
    {
       return;
    }
    
    FSeek( RVA2FOA(NtHeader.OptionalHeader.DataDirArray.DebugDirectory.VirtualAddress) );

    local ULONG ulDirCount=0;
    ulDirCount = NtHeader.OptionalHeader.DataDirArray.DebugDirectory.Size / 0x1C; // sizeof(IMAGE_DEBUG_DIRECTORY)
    IMAGE_DEBUG_DIRECTORY DebugDirectory[ulDirCount] <optimize=false>;
}

// IMAGE_DIRECTORY_ENTRY_TLS
void ParseTLS()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.TLSDirectory.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.TLSDirectory.Size == 0) )
    {
       return;
    }

    //FixMe
}

// IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT
void ParseBoundImport()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.BoundImportDirectory.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.BoundImportDirectory.Size == 0) )
    {
       return;
    }
    //FixMe
}

// IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT
void ParseDelayImport()
{
    if ( (NtHeader.OptionalHeader.DataDirArray.DelayLoadImportDescriptors.VirtualAddress == 0) || (NtHeader.OptionalHeader.DataDirArray.DelayLoadImportDescriptors.Size == 0) )
    {
       return;
    }
    //FixMe
}

ULONG RVA2FOA(ULONG ulRVA)
{
    local int i=0;

    for (i = 0; i < NtHeader.FileHeader.NumberOfSections; i++)
    {
        if ( (ulRVA >= SectionHeaders[i].VirtualAddress) && (ulRVA <= SectionHeaders[i].VirtualAddress + SectionHeaders[i].SizeOfRawData) )
        {
          return SectionHeaders[i].PointerToRawData + (ulRVA - SectionHeaders[i].VirtualAddress);
        }
    }
    return 0;
}

int CalcImageNtHeadersSize(IMAGE_NT_HEADERS& stNtHeader)
{
    local WORD OptionalHeaderMagic = ReadShort(startof(stNtHeader) + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) );

    if (0x10B ==  OptionalHeaderMagic)
    {
        Printf("PE32\n");
        return 0xF8;    //sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER32);
    }
    else if (0x20B == OptionalHeaderMagic)
    {
        Printf("PE64\n");
        return 0x108;   //sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER64);
    }
    else
    {
        return sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + 0;
    }
    return 0;
}


/**** READ AND WRITE UTILITY FUNCTIONS ****/
string ReadImageSectionHeader(IMAGE_SECTION_HEADER& h)
{
    return h.Name;
}

string ReadSectionData(IMAGE_SECTION_DATA& SecData)
{
    return SecData.sSecName;
}

string ReadImageDataDirectory(IMAGE_DATA_DIRECTORY& datadir)
{
    if (datadir.Size || datadir.VirtualAddress)
    {
        return Str("%08X: size = %u", datadir.VirtualAddress, datadir.Size);
    }
    return "";
}

string ReadDllCharacteristics(DLL_CHARACTERISTICS& c)
{
    string result = "";
    if (c.IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA)
    {
        result += "HighEntropyVA, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
    {
        result += "DynamicBase, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY)
    {
        result += "ForceIntegrity, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
    {
        result += "NXCompat, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_NO_ISOLATION)
    {
        result += "NoIsolation, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_NO_SEH)
    {
        result += "NoSEH, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_WDM_DRIVER)
    {
        result += "WDMDriver, ";
    }
    if (c.IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)
    {
        result += "TSAware, ";
    }
    return SubStr(result, 0, Strlen(result) - 2);
}

const WORD WIN_CERT_REVISION_1_0 = 0x0100;
const WORD WIN_CERT_REVISION_2_0 = 0x0200;

string ReadWinCertRevision(WORD& r)
{
    switch (r)
    {
    case WIN_CERT_REVISION_1_0:
        return Str("WIN_CERT_REVISION_1_0 (0x%04X)", r);
    case WIN_CERT_REVISION_2_0:
        return Str("WIN_CERT_REVISION_2_0 (0x%04X)", r);
    default:
        return Str("<unknown> (0x%04X)", r);
    }
}

const WORD WIN_CERT_TYPE_X509 = 0x0001;
const WORD WIN_CERT_TYPE_PKCS_SIGNED_DATA = 0x0002;
const WORD WIN_CERT_TYPE_RESERVED_1 = 0x0003;
const WORD WIN_CERT_TYPE_TS_STACK_SIGNED = 0x0004;
const WORD WIN_CERT_TYPE_PKCS1_SIGN = 0x0009;

string ReadWinCertCertificateType(WORD& t)
{
    switch (t)
    {
    case WIN_CERT_TYPE_X509:
        return Str("WIN_CERT_TYPE_X509 (0x%04X)", t);
    case WIN_CERT_TYPE_PKCS_SIGNED_DATA:
        return Str("WIN_CERT_TYPE_PKCS_SIGNED_DATA (0x%04X)", t);
    case WIN_CERT_TYPE_RESERVED_1:
        return Str("WIN_CERT_TYPE_RESERVED_1 (0x%04X)", t);
    case WIN_CERT_TYPE_TS_STACK_SIGNED:
        return Str("WIN_CERT_TYPE_TS_STACK_SIGNED (0x%04X)", t);
    case WIN_CERT_TYPE_PKCS1_SIGN:
        return Str("WIN_CERT_TYPE_PKCS1_SIGN (0x%04X)", t);
    default:
        return Str("<unknown> (0x%04X)", t);
    }
}

string ReadImageImportDescriptor(IMAGE_IMPORT_DESCRIPTOR& ImportDescriptor)
{
    return ReadString(RVA2FOA(ImportDescriptor.Name));
}

string ReadExportByName(IMAGE_EXPORT_BY_NAME& ExportByName)
{
    return ExportByName.Function;
}

string GetRichIdVersionString(DWORD& idVersion)
{
    // from https://github.com/dishather/richprint/blob/master/comp_id.txt
    local string sIdVersion;
    if (idVersion == 0x00010000) SPrintf(sIdVersion, "[---] Unmarked objects");
    else if (idVersion == 0x00000000) SPrintf(sIdVersion, "[---] Unmarked objects (old)");
    else if (idVersion == 0x01047cc1) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x01037cc1) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x01057cc1) SPrintf(sIdVersion, "[C++] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x00ff7cc1) SPrintf(sIdVersion, "[RES] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x01027cc1) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x01007cc1) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x01017cc1) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.3 build 31937");
    else if (idVersion == 0x01047cbf) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x01037cbf) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x01057cbf) SPrintf(sIdVersion, "[C++] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x00ff7cbf) SPrintf(sIdVersion, "[RES] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x01027cbf) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x01007cbf) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x01017cbf) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.2 build 31935");
    else if (idVersion == 0x01047b8e) SPrintf(sIdVersion, "[ C ] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x01037b8e) SPrintf(sIdVersion, "[ASM] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x01057b8e) SPrintf(sIdVersion, "[C++] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x00ff7b8e) SPrintf(sIdVersion, "[RES] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x01027b8e) SPrintf(sIdVersion, "[LNK] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x01007b8e) SPrintf(sIdVersion, "[EXP] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x01017b8e) SPrintf(sIdVersion, "[IMP] VS2022 v17.3.4 build 31630");
    else if (idVersion == 0x01047a64) SPrintf(sIdVersion, "[ C ] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x01037a64) SPrintf(sIdVersion, "[ASM] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x01057a64) SPrintf(sIdVersion, "[C++] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x00ff7a64) SPrintf(sIdVersion, "[RES] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x01027a64) SPrintf(sIdVersion, "[LNK] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x01007a64) SPrintf(sIdVersion, "[EXP] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x01017a64) SPrintf(sIdVersion, "[IMP] VS2022 v17.2.5 build 31332");
    else if (idVersion == 0x01047a61) SPrintf(sIdVersion, "[ C ] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x01037a61) SPrintf(sIdVersion, "[ASM] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x01057a61) SPrintf(sIdVersion, "[C++] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x00ff7a61) SPrintf(sIdVersion, "[RES] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x01027a61) SPrintf(sIdVersion, "[LNK] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x01007a61) SPrintf(sIdVersion, "[EXP] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x01017a61) SPrintf(sIdVersion, "[IMP] VS2022 v17.2.1 build 31329");
    else if (idVersion == 0x01047d7c) SPrintf(sIdVersion, "[ C ] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x01037d7c) SPrintf(sIdVersion, "[ASM] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x01057d7c) SPrintf(sIdVersion, "[C++] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x00ff7d7c) SPrintf(sIdVersion, "[RES] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x01027d7c) SPrintf(sIdVersion, "[LNK] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x01007d7c) SPrintf(sIdVersion, "[EXP] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x01017d7c) SPrintf(sIdVersion, "[IMP] VS2022 v17.5.0 pre 2.0 build 32124");
    else if (idVersion == 0x01047d13) SPrintf(sIdVersion, "[ C ] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x01037d13) SPrintf(sIdVersion, "[ASM] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x01057d13) SPrintf(sIdVersion, "[C++] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x00ff7d13) SPrintf(sIdVersion, "[RES] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x01027d13) SPrintf(sIdVersion, "[LNK] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x01007d13) SPrintf(sIdVersion, "[EXP] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x01017d13) SPrintf(sIdVersion, "[IMP] VS2022 v17.5.0 pre 1.0 build 32019");
    else if (idVersion == 0x01047cbd) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x01037cbd) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x01057cbd) SPrintf(sIdVersion, "[C++] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x00ff7cbd) SPrintf(sIdVersion, "[RES] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x01027cbd) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x01007cbd) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x01017cbd) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.0 pre 6.0 build 31933");
    else if (idVersion == 0x01047cbc) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x01037cbc) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x01057cbc) SPrintf(sIdVersion, "[C++] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x00ff7cbc) SPrintf(sIdVersion, "[RES] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x01027cbc) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x01007cbc) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x01017cbc) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.0 pre 5.0 build 31932");
    else if (idVersion == 0x01047cbb) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x01037cbb) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x01057cbb) SPrintf(sIdVersion, "[C++] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x00ff7cbb) SPrintf(sIdVersion, "[RES] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x01027cbb) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x01007cbb) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x01017cbb) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.0 pre 4.0 build 31931");
    else if (idVersion == 0x01047cb1) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x01037cb1) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x01057cb1) SPrintf(sIdVersion, "[C++] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x00ff7cb1) SPrintf(sIdVersion, "[RES] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x01027cb1) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x01007cb1) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x01017cb1) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.0 pre 3.0 build 31921");
    else if (idVersion == 0x01047c4f) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x01037c4f) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x01057c4f) SPrintf(sIdVersion, "[C++] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x00ff7c4f) SPrintf(sIdVersion, "[RES] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x01027c4f) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x01007c4f) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x01017c4f) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.0 pre 2.0 build 31823");
    else if (idVersion == 0x01047be9) SPrintf(sIdVersion, "[ C ] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x01037be9) SPrintf(sIdVersion, "[ASM] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x01057be9) SPrintf(sIdVersion, "[C++] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x00ff7be9) SPrintf(sIdVersion, "[RES] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x01027be9) SPrintf(sIdVersion, "[LNK] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x01007be9) SPrintf(sIdVersion, "[EXP] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x01017be9) SPrintf(sIdVersion, "[IMP] VS2022 v17.4.0 pre 1.0 build 31721");
    else if (idVersion == 0x01047b8d) SPrintf(sIdVersion, "[ C ] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x01037b8d) SPrintf(sIdVersion, "[ASM] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x01057b8d) SPrintf(sIdVersion, "[C++] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x00ff7b8d) SPrintf(sIdVersion, "[RES] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x01027b8d) SPrintf(sIdVersion, "[LNK] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x01007b8d) SPrintf(sIdVersion, "[EXP] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x01017b8d) SPrintf(sIdVersion, "[IMP] VS2022 v17.3.0 build 31629");
    else if (idVersion == 0x01047b8b) SPrintf(sIdVersion, "[ C ] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x01037b8b) SPrintf(sIdVersion, "[ASM] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x01057b8b) SPrintf(sIdVersion, "[C++] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x00ff7b8b) SPrintf(sIdVersion, "[RES] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x01027b8b) SPrintf(sIdVersion, "[LNK] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x01007b8b) SPrintf(sIdVersion, "[EXP] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x01017b8b) SPrintf(sIdVersion, "[IMP] VS2022 v17.3.0 pre 3.0 build 31627");
    else if (idVersion == 0x01047b1d) SPrintf(sIdVersion, "[ C ] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x01037b1d) SPrintf(sIdVersion, "[ASM] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x01057b1d) SPrintf(sIdVersion, "[C++] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x00ff7b1d) SPrintf(sIdVersion, "[RES] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x01027b1d) SPrintf(sIdVersion, "[LNK] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x01007b1d) SPrintf(sIdVersion, "[EXP] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x01017b1d) SPrintf(sIdVersion, "[IMP] VS2022 v17.3.0 pre 2.0 build 31517");
    else if (idVersion == 0x01047ac0) SPrintf(sIdVersion, "[ C ] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x01037ac0) SPrintf(sIdVersion, "[ASM] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x01057ac0) SPrintf(sIdVersion, "[C++] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x00ff7ac0) SPrintf(sIdVersion, "[RES] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x01027ac0) SPrintf(sIdVersion, "[LNK] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x01007ac0) SPrintf(sIdVersion, "[EXP] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x01017ac0) SPrintf(sIdVersion, "[IMP] VS2022 v17.3.0 pre 1.0 build 31424");
    else if (idVersion == 0x01047a60) SPrintf(sIdVersion, "[ C ] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x01037a60) SPrintf(sIdVersion, "[ASM] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x01057a60) SPrintf(sIdVersion, "[C++] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x00ff7a60) SPrintf(sIdVersion, "[RES] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x01027a60) SPrintf(sIdVersion, "[LNK] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x01007a60) SPrintf(sIdVersion, "[EXP] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x01017a60) SPrintf(sIdVersion, "[IMP] VS2022 v17.2.0 build 31328");
    else if (idVersion == 0x01047a5e) SPrintf(sIdVersion, "[ C ] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x01037a5e) SPrintf(sIdVersion, "[ASM] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x01057a5e) SPrintf(sIdVersion, "[C++] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x00ff7a5e) SPrintf(sIdVersion, "[RES] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x01027a5e) SPrintf(sIdVersion, "[LNK] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x01007a5e) SPrintf(sIdVersion, "[EXP] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x01017a5e) SPrintf(sIdVersion, "[IMP] VS2022 v17.2.0 pre 3.0 build 31326");
    else if (idVersion == 0x01047a46) SPrintf(sIdVersion, "[ C ] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x01037a46) SPrintf(sIdVersion, "[ASM] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x01057a46) SPrintf(sIdVersion, "[C++] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x00ff7a46) SPrintf(sIdVersion, "[RES] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x01027a46) SPrintf(sIdVersion, "[LNK] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x01007a46) SPrintf(sIdVersion, "[EXP] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x01017a46) SPrintf(sIdVersion, "[IMP] VS2022 v17.2.0 pre 2.1 build 31302");
    else if (idVersion == 0x0104798a) SPrintf(sIdVersion, "[ C ] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x0103798a) SPrintf(sIdVersion, "[ASM] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x0105798a) SPrintf(sIdVersion, "[C++] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x00ff798a) SPrintf(sIdVersion, "[RES] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x0102798a) SPrintf(sIdVersion, "[LNK] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x0100798a) SPrintf(sIdVersion, "[EXP] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x0101798a) SPrintf(sIdVersion, "[IMP] VS2022 v17.2.0 pre 1.0 build 31114");
    else if (idVersion == 0x01047980) SPrintf(sIdVersion, "[ C ] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x01037980) SPrintf(sIdVersion, "[ASM] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x01057980) SPrintf(sIdVersion, "[C++] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x00ff7980) SPrintf(sIdVersion, "[RES] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x01027980) SPrintf(sIdVersion, "[LNK] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x01007980) SPrintf(sIdVersion, "[EXP] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x01017980) SPrintf(sIdVersion, "[IMP] VS2022 v17.1.0 pre 5.0 build 31104");
    else if (idVersion == 0x0104797f) SPrintf(sIdVersion, "[ C ] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x0103797f) SPrintf(sIdVersion, "[ASM] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x0105797f) SPrintf(sIdVersion, "[C++] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x00ff797f) SPrintf(sIdVersion, "[RES] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x0102797f) SPrintf(sIdVersion, "[LNK] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x0100797f) SPrintf(sIdVersion, "[EXP] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x0101797f) SPrintf(sIdVersion, "[IMP] VS2022 v17.1.0 pre 3.0 build 31103");
    else if (idVersion == 0x010478c7) SPrintf(sIdVersion, "[ C ] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x010378c7) SPrintf(sIdVersion, "[ASM] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x010578c7) SPrintf(sIdVersion, "[C++] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x00ff78c7) SPrintf(sIdVersion, "[RES] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x010278c7) SPrintf(sIdVersion, "[LNK] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x010078c7) SPrintf(sIdVersion, "[EXP] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x010178c7) SPrintf(sIdVersion, "[IMP] VS2022 v17.1.0 pre 2.0 build 30919");
    else if (idVersion == 0x01047862) SPrintf(sIdVersion, "[ C ] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x01037862) SPrintf(sIdVersion, "[ASM] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x01057862) SPrintf(sIdVersion, "[C++] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x00ff7862) SPrintf(sIdVersion, "[RES] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x01027862) SPrintf(sIdVersion, "[LNK] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x01007862) SPrintf(sIdVersion, "[EXP] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x01017862) SPrintf(sIdVersion, "[IMP] VS2022 v17.1.0 pre 1.0 build 30818");
    else if (idVersion == 0x010477f1) SPrintf(sIdVersion, "[ C ] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x010377f1) SPrintf(sIdVersion, "[ASM] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x010577f1) SPrintf(sIdVersion, "[C++] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x00ff77f1) SPrintf(sIdVersion, "[RES] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x010277f1) SPrintf(sIdVersion, "[LNK] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x010077f1) SPrintf(sIdVersion, "[EXP] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x010177f1) SPrintf(sIdVersion, "[IMP] VS2022 v17.0.0 pre 7.0 build 30705");
    else if (idVersion == 0x010477f0) SPrintf(sIdVersion, "[ C ] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x010377f0) SPrintf(sIdVersion, "[ASM] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x010577f0) SPrintf(sIdVersion, "[C++] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x00ff77f0) SPrintf(sIdVersion, "[RES] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x010277f0) SPrintf(sIdVersion, "[LNK] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x010077f0) SPrintf(sIdVersion, "[EXP] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x010177f0) SPrintf(sIdVersion, "[IMP] VS2022 v17.0.0 pre 5.0 build 30704");
    else if (idVersion == 0x01047740) SPrintf(sIdVersion, "[ C ] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x01037740) SPrintf(sIdVersion, "[ASM] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x01057740) SPrintf(sIdVersion, "[C++] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x00ff7740) SPrintf(sIdVersion, "[RES] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x01027740) SPrintf(sIdVersion, "[LNK] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x01007740) SPrintf(sIdVersion, "[EXP] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x01017740) SPrintf(sIdVersion, "[IMP] VS2022 v17.0.0 pre 4.0 build 30528");
    else if (idVersion == 0x010476d7) SPrintf(sIdVersion, "[ C ] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x010376d7) SPrintf(sIdVersion, "[ASM] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x010576d7) SPrintf(sIdVersion, "[C++] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x00ff76d7) SPrintf(sIdVersion, "[RES] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x010276d7) SPrintf(sIdVersion, "[LNK] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x010076d7) SPrintf(sIdVersion, "[EXP] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x010176d7) SPrintf(sIdVersion, "[IMP] VS2022 v17.0.0 pre 3.1 build 30423");
    else if (idVersion == 0x010476c1) SPrintf(sIdVersion, "[ C ] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x010376c1) SPrintf(sIdVersion, "[ASM] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x010576c1) SPrintf(sIdVersion, "[C++] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x00ff76c1) SPrintf(sIdVersion, "[RES] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x010276c1) SPrintf(sIdVersion, "[LNK] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x010076c1) SPrintf(sIdVersion, "[EXP] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x010176c1) SPrintf(sIdVersion, "[IMP] VS2022 v17.0.0 preview2 build 30401");
    else if (idVersion == 0x010475c3) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x010375c3) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x010575c3) SPrintf(sIdVersion, "[C++] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x00ff75c3) SPrintf(sIdVersion, "[RES] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x010275c3) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x010075c3) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x010175c3) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.21 build 30147");
    else if (idVersion == 0x010475c2) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x010375c2) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x010575c2) SPrintf(sIdVersion, "[C++] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x00ff75c2) SPrintf(sIdVersion, "[RES] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x010275c2) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x010075c2) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x010175c2) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.17 build 30146");
    else if (idVersion == 0x010475c1) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x010375c1) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x010575c1) SPrintf(sIdVersion, "[C++] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x00ff75c1) SPrintf(sIdVersion, "[RES] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x010275c1) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x010075c1) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x010175c1) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.15 build 30145");
    else if (idVersion == 0x010475bf) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x010375bf) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x010575bf) SPrintf(sIdVersion, "[C++] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x00ff75bf) SPrintf(sIdVersion, "[RES] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x010275bf) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x010075bf) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x010175bf) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.13 build 30143");
    else if (idVersion == 0x010475bc) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x010375bc) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x010575bc) SPrintf(sIdVersion, "[C++] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x00ff75bc) SPrintf(sIdVersion, "[RES] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x010275bc) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x010075bc) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x010175bc) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.10 build 30140");
    else if (idVersion == 0x010475bb) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x010375bb) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x010575bb) SPrintf(sIdVersion, "[C++] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x00ff75bb) SPrintf(sIdVersion, "[RES] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x010275bb) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x010075bb) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x010175bb) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.9 build 30139");
    else if (idVersion == 0x010475ba) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x010375ba) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x010575ba) SPrintf(sIdVersion, "[C++] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x00ff75ba) SPrintf(sIdVersion, "[RES] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x010275ba) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x010075ba) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x010175ba) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.8 build 30138");
    else if (idVersion == 0x010475b9) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x010375b9) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x010575b9) SPrintf(sIdVersion, "[C++] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x00ff75b9) SPrintf(sIdVersion, "[RES] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x010275b9) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x010075b9) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x010175b9) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.6 build 30137");
    else if (idVersion == 0x010475b8) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x010375b8) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x010575b8) SPrintf(sIdVersion, "[C++] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x00ff75b8) SPrintf(sIdVersion, "[RES] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x010275b8) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x010075b8) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x010175b8) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.5 build 30136");
    else if (idVersion == 0x010475b5) SPrintf(sIdVersion, "[ C ] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x010375b5) SPrintf(sIdVersion, "[ASM] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x010575b5) SPrintf(sIdVersion, "[C++] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x00ff75b5) SPrintf(sIdVersion, "[RES] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x010275b5) SPrintf(sIdVersion, "[LNK] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x010075b5) SPrintf(sIdVersion, "[EXP] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x010175b5) SPrintf(sIdVersion, "[IMP] VS2019 v16.11.1 build 30133");
    else if (idVersion == 0x01047558) SPrintf(sIdVersion, "[ C ] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x01037558) SPrintf(sIdVersion, "[ASM] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x01057558) SPrintf(sIdVersion, "[C++] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x00ff7558) SPrintf(sIdVersion, "[RES] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x01027558) SPrintf(sIdVersion, "[LNK] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x01007558) SPrintf(sIdVersion, "[EXP] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x01017558) SPrintf(sIdVersion, "[IMP] VS2019 v16.10.4 build 30040");
    else if (idVersion == 0x01047556) SPrintf(sIdVersion, "[ C ] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x01037556) SPrintf(sIdVersion, "[ASM] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x01057556) SPrintf(sIdVersion, "[C++] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x00ff7556) SPrintf(sIdVersion, "[RES] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x01027556) SPrintf(sIdVersion, "[LNK] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x01007556) SPrintf(sIdVersion, "[EXP] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x01017556) SPrintf(sIdVersion, "[IMP] VS2019 v16.10.3 build 30038");
    else if (idVersion == 0x01047555) SPrintf(sIdVersion, "[ C ] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x01037555) SPrintf(sIdVersion, "[ASM] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x01057555) SPrintf(sIdVersion, "[C++] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x00ff7555) SPrintf(sIdVersion, "[RES] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x01027555) SPrintf(sIdVersion, "[LNK] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x01007555) SPrintf(sIdVersion, "[EXP] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x01017555) SPrintf(sIdVersion, "[IMP] VS2019 v16.10.0 build 30037");
    else if (idVersion == 0x010474db) SPrintf(sIdVersion, "[ C ] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x010374db) SPrintf(sIdVersion, "[ASM] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x010574db) SPrintf(sIdVersion, "[C++] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x00ff74db) SPrintf(sIdVersion, "[RES] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x010274db) SPrintf(sIdVersion, "[LNK] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x010074db) SPrintf(sIdVersion, "[EXP] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x010174db) SPrintf(sIdVersion, "[IMP] VS2019 v16.9.5 build 29915");
    else if (idVersion == 0x010474da) SPrintf(sIdVersion, "[ C ] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x010374da) SPrintf(sIdVersion, "[ASM] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x010574da) SPrintf(sIdVersion, "[C++] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x00ff74da) SPrintf(sIdVersion, "[RES] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x010274da) SPrintf(sIdVersion, "[LNK] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x010074da) SPrintf(sIdVersion, "[EXP] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x010174da) SPrintf(sIdVersion, "[IMP] VS2019 v16.9.4 build 29914");
    else if (idVersion == 0x010474d9) SPrintf(sIdVersion, "[ C ] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x010374d9) SPrintf(sIdVersion, "[ASM] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x010574d9) SPrintf(sIdVersion, "[C++] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x00ff74d9) SPrintf(sIdVersion, "[RES] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x010274d9) SPrintf(sIdVersion, "[LNK] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x010074d9) SPrintf(sIdVersion, "[EXP] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x010174d9) SPrintf(sIdVersion, "[IMP] VS2019 v16.9.2 build 29913");
    else if (idVersion == 0x01047299) SPrintf(sIdVersion, "[ C ] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x01037299) SPrintf(sIdVersion, "[ASM] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x01057299) SPrintf(sIdVersion, "[C++] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x00ff7299) SPrintf(sIdVersion, "[RES] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x01027299) SPrintf(sIdVersion, "[LNK] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x01007299) SPrintf(sIdVersion, "[EXP] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x01017299) SPrintf(sIdVersion, "[IMP] VS2019 v16.8.5 build 29337");
    else if (idVersion == 0x01047298) SPrintf(sIdVersion, "[ C ] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x01037298) SPrintf(sIdVersion, "[ASM] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x01057298) SPrintf(sIdVersion, "[C++] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x00ff7298) SPrintf(sIdVersion, "[RES] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x01027298) SPrintf(sIdVersion, "[LNK] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x01007298) SPrintf(sIdVersion, "[EXP] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x01017298) SPrintf(sIdVersion, "[IMP] VS2019 v16.8.4 build 29336");
    else if (idVersion == 0x01047297) SPrintf(sIdVersion, "[ C ] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x01037297) SPrintf(sIdVersion, "[ASM] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x01057297) SPrintf(sIdVersion, "[C++] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x00ff7297) SPrintf(sIdVersion, "[RES] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x01027297) SPrintf(sIdVersion, "[LNK] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x01007297) SPrintf(sIdVersion, "[EXP] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x01017297) SPrintf(sIdVersion, "[IMP] VS2019 v16.8.3 build 29335");
    else if (idVersion == 0x01047296) SPrintf(sIdVersion, "[ C ] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x01037296) SPrintf(sIdVersion, "[ASM] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x01057296) SPrintf(sIdVersion, "[C++] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x00ff7296) SPrintf(sIdVersion, "[RES] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x01027296) SPrintf(sIdVersion, "[LNK] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x01007296) SPrintf(sIdVersion, "[EXP] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x01017296) SPrintf(sIdVersion, "[IMP] VS2019 v16.8.2 build 29334");
    else if (idVersion == 0x010471b8) SPrintf(sIdVersion, "[ C ] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x010371b8) SPrintf(sIdVersion, "[ASM] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x010571b8) SPrintf(sIdVersion, "[C++] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x00ff71b8) SPrintf(sIdVersion, "[RES] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x010271b8) SPrintf(sIdVersion, "[LNK] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x010071b8) SPrintf(sIdVersion, "[EXP] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x010171b8) SPrintf(sIdVersion, "[IMP] VS2019 v16.7.5 build 29112");
    else if (idVersion == 0x010471b7) SPrintf(sIdVersion, "[ C ] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x010371b7) SPrintf(sIdVersion, "[ASM] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x010571b7) SPrintf(sIdVersion, "[C++] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x00ff71b7) SPrintf(sIdVersion, "[RES] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x010271b7) SPrintf(sIdVersion, "[LNK] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x010071b7) SPrintf(sIdVersion, "[EXP] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x010171b7) SPrintf(sIdVersion, "[IMP] VS2019 v16.7.1 build 29111");
    else if (idVersion == 0x010471b6) SPrintf(sIdVersion, "[ C ] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x010371b6) SPrintf(sIdVersion, "[ASM] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x010571b6) SPrintf(sIdVersion, "[C++] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x00ff71b6) SPrintf(sIdVersion, "[RES] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x010271b6) SPrintf(sIdVersion, "[LNK] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x010071b6) SPrintf(sIdVersion, "[EXP] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x010171b6) SPrintf(sIdVersion, "[IMP] VS2019 v16.7.0 build 29110");
    else if (idVersion == 0x01047086) SPrintf(sIdVersion, "[ C ] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x01037086) SPrintf(sIdVersion, "[ASM] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x01057086) SPrintf(sIdVersion, "[C++] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x00ff7086) SPrintf(sIdVersion, "[RES] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x01027086) SPrintf(sIdVersion, "[LNK] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x01007086) SPrintf(sIdVersion, "[EXP] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x01017086) SPrintf(sIdVersion, "[IMP] VS2019 v16.6.2 build 28806");
    else if (idVersion == 0x01047085) SPrintf(sIdVersion, "[ C ] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x01037085) SPrintf(sIdVersion, "[ASM] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x01057085) SPrintf(sIdVersion, "[C++] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x00ff7085) SPrintf(sIdVersion, "[RES] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x01027085) SPrintf(sIdVersion, "[LNK] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x01007085) SPrintf(sIdVersion, "[EXP] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x01017085) SPrintf(sIdVersion, "[IMP] VS2019 v16.6.0 build 28805");
    else if (idVersion == 0x01046fc6) SPrintf(sIdVersion, "[ C ] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x01036fc6) SPrintf(sIdVersion, "[ASM] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x01056fc6) SPrintf(sIdVersion, "[C++] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x00ff6fc6) SPrintf(sIdVersion, "[RES] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x01026fc6) SPrintf(sIdVersion, "[LNK] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x01006fc6) SPrintf(sIdVersion, "[EXP] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x01016fc6) SPrintf(sIdVersion, "[IMP] VS2019 v16.5.5 build 28614");
    else if (idVersion == 0x01046e9b) SPrintf(sIdVersion, "[ C ] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x01036e9b) SPrintf(sIdVersion, "[ASM] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x01056e9b) SPrintf(sIdVersion, "[C++] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x00ff6e9b) SPrintf(sIdVersion, "[RES] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x01026e9b) SPrintf(sIdVersion, "[LNK] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x01006e9b) SPrintf(sIdVersion, "[EXP] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x01016e9b) SPrintf(sIdVersion, "[IMP] VS2019 v16.4.3 build 28315");
    else if (idVersion == 0x01046b74) SPrintf(sIdVersion, "[ C ] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x01036b74) SPrintf(sIdVersion, "[ASM] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x01056b74) SPrintf(sIdVersion, "[C++] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x00ff6b74) SPrintf(sIdVersion, "[RES] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x01026b74) SPrintf(sIdVersion, "[LNK] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x01006b74) SPrintf(sIdVersion, "[EXP] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x01016b74) SPrintf(sIdVersion, "[IMP] VS2019 v16.0.0 build 27508");
    else if (idVersion == 0x010464ea) SPrintf(sIdVersion, "[ C ] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x010364ea) SPrintf(sIdVersion, "[ASM] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x010564ea) SPrintf(sIdVersion, "[C++] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x00ff64ea) SPrintf(sIdVersion, "[RES] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x010264ea) SPrintf(sIdVersion, "[LNK] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x010064ea) SPrintf(sIdVersion, "[EXP] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x010164ea) SPrintf(sIdVersion, "[IMP] VS2017 v15.5.4 build 25834");
    else if (idVersion == 0x01045e97) SPrintf(sIdVersion, "[ C ] VS2015 UPD3.1 build 24215");
    else if (idVersion == 0x01055e97) SPrintf(sIdVersion, "[C++] VS2015 UPD3.1 build 24215");
    else if (idVersion == 0x01025e97) SPrintf(sIdVersion, "[LNK] VS2015 UPD3.1 build 24215");
    else if (idVersion == 0x01005e97) SPrintf(sIdVersion, "[EXP] VS2015 UPD3.1 build 24215");
    else if (idVersion == 0x01015e97) SPrintf(sIdVersion, "[IMP] VS2015 UPD3.1 build 24215");
    else if (idVersion == 0x01045e95) SPrintf(sIdVersion, "[ C ] VS2015 UPD3 build 24213");
    else if (idVersion == 0x01035e92) SPrintf(sIdVersion, "[ASM] VS2015 UPD3 build 24210");
    else if (idVersion == 0x01055e95) SPrintf(sIdVersion, "[C++] VS2015 UPD3 build 24213");
    else if (idVersion == 0x00ff5e92) SPrintf(sIdVersion, "[RES] VS2015 UPD3 build 24210");
    else if (idVersion == 0x01025e95) SPrintf(sIdVersion, "[LNK] VS2015 UPD3 build 24213");
    else if (idVersion == 0x01005e95) SPrintf(sIdVersion, "[EXP] VS2015 UPD3 build 24213");
    else if (idVersion == 0x01015e95) SPrintf(sIdVersion, "[IMP] VS2015 UPD3 build 24213");
    else if (idVersion == 0x01045d6e) SPrintf(sIdVersion, "[ C ] VS2015 UPD2 build 23918");
    else if (idVersion == 0x01035d6e) SPrintf(sIdVersion, "[ASM] VS2015 UPD2 build 23918");
    else if (idVersion == 0x01055d6e) SPrintf(sIdVersion, "[C++] VS2015 UPD2 build 23918");
    else if (idVersion == 0x00ff5d6e) SPrintf(sIdVersion, "[RES] VS2015 UPD2 build 23918");
    else if (idVersion == 0x01025d6e) SPrintf(sIdVersion, "[LNK] VS2015 UPD2 build 23918");
    else if (idVersion == 0x01005d6e) SPrintf(sIdVersion, "[EXP] VS2015 UPD2 build 23918");
    else if (idVersion == 0x01015d6e) SPrintf(sIdVersion, "[IMP] VS2015 UPD2 build 23918");
    else if (idVersion == 0x01045bd2) SPrintf(sIdVersion, "[ C ] VS2015 UPD1 build 23506");
    else if (idVersion == 0x01035bd2) SPrintf(sIdVersion, "[ASM] VS2015 UPD1 build 23506");
    else if (idVersion == 0x01055bd2) SPrintf(sIdVersion, "[C++] VS2015 UPD1 build 23506");
    else if (idVersion == 0x00ff5bd2) SPrintf(sIdVersion, "[RES] VS2015 UPD1 build 23506");
    else if (idVersion == 0x01025bd2) SPrintf(sIdVersion, "[LNK] VS2015 UPD1 build 23506");
    else if (idVersion == 0x01005bd2) SPrintf(sIdVersion, "[EXP] VS2015 UPD1 build 23506");
    else if (idVersion == 0x01015bd2) SPrintf(sIdVersion, "[IMP] VS2015 UPD1 build 23506");
    else if (idVersion == 0x010459f2) SPrintf(sIdVersion, "[ C ] VS2015 build 23026");
    else if (idVersion == 0x010359f2) SPrintf(sIdVersion, "[ASM] VS2015 build 23026");
    else if (idVersion == 0x010559f2) SPrintf(sIdVersion, "[C++] VS2015 build 23026");
    else if (idVersion == 0x00ff59f2) SPrintf(sIdVersion, "[RES] VS2015 build 23026");
    else if (idVersion == 0x010259f2) SPrintf(sIdVersion, "[LNK] VS2015 build 23026");
    else if (idVersion == 0x010059f2) SPrintf(sIdVersion, "[EXP] VS2015 build 23026");
    else if (idVersion == 0x010159f2) SPrintf(sIdVersion, "[IMP] VS2015 build 23026");
    else if (idVersion == 0x00e09eb5) SPrintf(sIdVersion, "[ C ] VS2013 UPD5 build 40629");
    else if (idVersion == 0x00e19eb5) SPrintf(sIdVersion, "[C++] VS2013 UPD5 build 40629");
    else if (idVersion == 0x00de9eb5) SPrintf(sIdVersion, "[LNK] VS2013 UPD5 build 40629");
    else if (idVersion == 0x00dc9eb5) SPrintf(sIdVersion, "[EXP] VS2013 UPD5 build 40629");
    else if (idVersion == 0x00dd9eb5) SPrintf(sIdVersion, "[IMP] VS2013 UPD5 build 40629");
    else if (idVersion == 0x00df9eb5) SPrintf(sIdVersion, "[ASM] VS2013 UPD5 build 40629");
    else if (idVersion == 0x00e0797d) SPrintf(sIdVersion, "[ C ] VS2013 UPD4 build 31101");
    else if (idVersion == 0x00e1797d) SPrintf(sIdVersion, "[C++] VS2013 UPD4 build 31101");
    else if (idVersion == 0x00de797d) SPrintf(sIdVersion, "[LNK] VS2013 UPD4 build 31101");
    else if (idVersion == 0x00dc797d) SPrintf(sIdVersion, "[EXP] VS2013 UPD4 build 31101");
    else if (idVersion == 0x00dd797d) SPrintf(sIdVersion, "[IMP] VS2013 UPD4 build 31101");
    else if (idVersion == 0x00df797d) SPrintf(sIdVersion, "[ASM] VS2013 UPD4 build 31101");
    else if (idVersion == 0x00e07803) SPrintf(sIdVersion, "[ C ] VS2013 UPD3 build 30723");
    else if (idVersion == 0x00e17803) SPrintf(sIdVersion, "[C++] VS2013 UPD3 build 30723");
    else if (idVersion == 0x00de7803) SPrintf(sIdVersion, "[LNK] VS2013 UPD3 build 30723");
    else if (idVersion == 0x00dc7803) SPrintf(sIdVersion, "[EXP] VS2013 UPD3 build 30723");
    else if (idVersion == 0x00dd7803) SPrintf(sIdVersion, "[IMP] VS2013 UPD3 build 30723");
    else if (idVersion == 0x00df7803) SPrintf(sIdVersion, "[ASM] VS2013 UPD3 build 30723");
    else if (idVersion == 0x00e07725) SPrintf(sIdVersion, "[ C ] VS2013 UPD2 build 30501");
    else if (idVersion == 0x00e17725) SPrintf(sIdVersion, "[C++] VS2013 UPD2 build 30501");
    else if (idVersion == 0x00de7725) SPrintf(sIdVersion, "[LNK] VS2013 UPD2 build 30501");
    else if (idVersion == 0x00dc7725) SPrintf(sIdVersion, "[EXP] VS2013 UPD2 build 30501");
    else if (idVersion == 0x00dd7725) SPrintf(sIdVersion, "[IMP] VS2013 UPD2 build 30501");
    else if (idVersion == 0x00df7725) SPrintf(sIdVersion, "[ASM] VS2013 UPD2 build 30501");
    else if (idVersion == 0x00e0520d) SPrintf(sIdVersion, "[ C ] VS2013 build 21005");
    else if (idVersion == 0x00e1520d) SPrintf(sIdVersion, "[C++] VS2013 build 21005");
    else if (idVersion == 0x00db520d) SPrintf(sIdVersion, "[RES] VS2013 build 21005");
    else if (idVersion == 0x00de520d) SPrintf(sIdVersion, "[LNK] VS2013 build 21005");
    else if (idVersion == 0x00dc520d) SPrintf(sIdVersion, "[EXP] VS2013 build 21005");
    else if (idVersion == 0x00dd520d) SPrintf(sIdVersion, "[IMP] VS2013 build 21005");
    else if (idVersion == 0x00df520d) SPrintf(sIdVersion, "[ASM] VS2013 build 21005");
    else if (idVersion == 0x00ceee66) SPrintf(sIdVersion, "[ C ] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00cfee66) SPrintf(sIdVersion, "[C++] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00cdee66) SPrintf(sIdVersion, "[ASM] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00c9ee66) SPrintf(sIdVersion, "[RES] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00ccee66) SPrintf(sIdVersion, "[LNK] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00caee66) SPrintf(sIdVersion, "[EXP] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00cbee66) SPrintf(sIdVersion, "[IMP] VS2012 UPD4 build 61030");
    else if (idVersion == 0x00ceecc2) SPrintf(sIdVersion, "[ C ] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00cfecc2) SPrintf(sIdVersion, "[C++] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00cdecc2) SPrintf(sIdVersion, "[ASM] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00c9ecc2) SPrintf(sIdVersion, "[RES] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00ccecc2) SPrintf(sIdVersion, "[LNK] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00caecc2) SPrintf(sIdVersion, "[EXP] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00cbecc2) SPrintf(sIdVersion, "[IMP] VS2012 UPD3 build 60610");
    else if (idVersion == 0x00ceeb9b) SPrintf(sIdVersion, "[ C ] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00cfeb9b) SPrintf(sIdVersion, "[C++] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00cdeb9b) SPrintf(sIdVersion, "[ASM] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00c9eb9b) SPrintf(sIdVersion, "[RES] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00cceb9b) SPrintf(sIdVersion, "[LNK] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00caeb9b) SPrintf(sIdVersion, "[EXP] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00cbeb9b) SPrintf(sIdVersion, "[IMP] VS2012 UPD2 build 60315");
    else if (idVersion == 0x00cec7a2) SPrintf(sIdVersion, "[ C ] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00cfc7a2) SPrintf(sIdVersion, "[C++] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00cdc7a2) SPrintf(sIdVersion, "[ASM] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00c9c7a2) SPrintf(sIdVersion, "[RES] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00ccc7a2) SPrintf(sIdVersion, "[LNK] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00cac7a2) SPrintf(sIdVersion, "[EXP] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00cbc7a2) SPrintf(sIdVersion, "[IMP] VS2012 UPD1 build 51106");
    else if (idVersion == 0x00cec627) SPrintf(sIdVersion, "[ C ] VS2012 build 50727");
    else if (idVersion == 0x00cfc627) SPrintf(sIdVersion, "[C++] VS2012 build 50727");
    else if (idVersion == 0x00c9c627) SPrintf(sIdVersion, "[RES] VS2012 build 50727");
    else if (idVersion == 0x00cdc627) SPrintf(sIdVersion, "[ASM] VS2012 build 50727");
    else if (idVersion == 0x00cac627) SPrintf(sIdVersion, "[EXP] VS2012 build 50727");
    else if (idVersion == 0x00cbc627) SPrintf(sIdVersion, "[IMP] VS2012 build 50727");
    else if (idVersion == 0x00ccc627) SPrintf(sIdVersion, "[LNK] VS2012 build 50727");
    else if (idVersion == 0x00aa9d1b) SPrintf(sIdVersion, "[ C ] VS2010 SP1 build 40219");
    else if (idVersion == 0x00ab9d1b) SPrintf(sIdVersion, "[C++] VS2010 SP1 build 40219");
    else if (idVersion == 0x009d9d1b) SPrintf(sIdVersion, "[LNK] VS2010 SP1 build 40219");
    else if (idVersion == 0x009a9d1b) SPrintf(sIdVersion, "[RES] VS2010 SP1 build 40219");
    else if (idVersion == 0x009b9d1b) SPrintf(sIdVersion, "[EXP] VS2010 SP1 build 40219");
    else if (idVersion == 0x009c9d1b) SPrintf(sIdVersion, "[IMP] VS2010 SP1 build 40219");
    else if (idVersion == 0x009e9d1b) SPrintf(sIdVersion, "[ASM] VS2010 SP1 build 40219");
    else if (idVersion == 0x00aa766f) SPrintf(sIdVersion, "[ C ] VS2010 build 30319");
    else if (idVersion == 0x00ab766f) SPrintf(sIdVersion, "[C++] VS2010 build 30319");
    else if (idVersion == 0x009d766f) SPrintf(sIdVersion, "[LNK] VS2010 build 30319");
    else if (idVersion == 0x009a766f) SPrintf(sIdVersion, "[RES] VS2010 build 30319");
    else if (idVersion == 0x009b766f) SPrintf(sIdVersion, "[EXP] VS2010 build 30319");
    else if (idVersion == 0x009c766f) SPrintf(sIdVersion, "[IMP] VS2010 build 30319");
    else if (idVersion == 0x009e766f) SPrintf(sIdVersion, "[ASM] VS2010 build 30319");
    else if (idVersion == 0x00837809) SPrintf(sIdVersion, "[ C ] VS2008 SP1 build 30729");
    else if (idVersion == 0x00847809) SPrintf(sIdVersion, "[C++] VS2008 SP1 build 30729");
    else if (idVersion == 0x00957809) SPrintf(sIdVersion, "[ASM] VS2008 SP1 build 30729");
    else if (idVersion == 0x00927809) SPrintf(sIdVersion, "[EXP] VS2008 SP1 build 30729");
    else if (idVersion == 0x00937809) SPrintf(sIdVersion, "[IMP] VS2008 SP1 build 30729");
    else if (idVersion == 0x00917809) SPrintf(sIdVersion, "[LNK] VS2008 SP1 build 30729");
    else if (idVersion == 0x0083521e) SPrintf(sIdVersion, "[ C ] VS2008 build 21022");
    else if (idVersion == 0x0084521e) SPrintf(sIdVersion, "[C++] VS2008 build 21022");
    else if (idVersion == 0x0091521e) SPrintf(sIdVersion, "[LNK] VS2008 build 21022");
    else if (idVersion == 0x0094521e) SPrintf(sIdVersion, "[RES] VS2008 build 21022");
    else if (idVersion == 0x0092521e) SPrintf(sIdVersion, "[EXP] VS2008 build 21022");
    else if (idVersion == 0x0093521e) SPrintf(sIdVersion, "[IMP] VS2008 build 21022");
    else if (idVersion == 0x0095521e) SPrintf(sIdVersion, "[ASM] VS2008 build 21022");
    else if (idVersion == 0x006dc627) SPrintf(sIdVersion, "[ C ] VS2005 build 50727");
    else if (idVersion == 0x006ec627) SPrintf(sIdVersion, "[C++] VS2005 build 50727");
    else if (idVersion == 0x0078c627) SPrintf(sIdVersion, "[LNK] VS2005 build 50727");
    else if (idVersion == 0x007cc627) SPrintf(sIdVersion, "[RES] VS2005 build 50727");
    else if (idVersion == 0x007ac627) SPrintf(sIdVersion, "[EXP] VS2005 build 50727");
    else if (idVersion == 0x007bc627) SPrintf(sIdVersion, "[IMP] VS2005 build 50727");
    else if (idVersion == 0x007dc627) SPrintf(sIdVersion, "[ASM] VS2005 build 50727");
    else if (idVersion == 0x005f178e) SPrintf(sIdVersion, "[ C ] VS2003 (.NET) SP1 build 6030");
    else if (idVersion == 0x0060178e) SPrintf(sIdVersion, "[C++] VS2003 (.NET) SP1 build 6030");
    else if (idVersion == 0x005a178e) SPrintf(sIdVersion, "[LNK] VS2003 (.NET) SP1 build 6030");
    else if (idVersion == 0x000f178e) SPrintf(sIdVersion, "[ASM] VS2003 (.NET) SP1 build 6030");
    else if (idVersion == 0x005c178e) SPrintf(sIdVersion, "[EXP] VS2003 (.NET) SP1 build 6030");
    else if (idVersion == 0x005d178e) SPrintf(sIdVersion, "[IMP] VS2003 (.NET) SP1 build 6030");
    else if (idVersion == 0x005f0c05) SPrintf(sIdVersion, "[ C ] VS2003 (.NET) build 3077");
    else if (idVersion == 0x00600c05) SPrintf(sIdVersion, "[C++] VS2003 (.NET) build 3077");
    else if (idVersion == 0x000f0c05) SPrintf(sIdVersion, "[ASM] VS2003 (.NET) build 3077");
    else if (idVersion == 0x005e0bec) SPrintf(sIdVersion, "[RES] VS2003 (.NET) build 3052");
    else if (idVersion == 0x005c0c05) SPrintf(sIdVersion, "[EXP] VS2003 (.NET) build 3077");
    else if (idVersion == 0x005d0c05) SPrintf(sIdVersion, "[IMP] VS2003 (.NET) build 3077");
    else if (idVersion == 0x005a0c05) SPrintf(sIdVersion, "[LNK] VS2003 (.NET) build 3077");
    else if (idVersion == 0x001c24fa) SPrintf(sIdVersion, "[ C ] VS2002 (.NET) build 9466");
    else if (idVersion == 0x001d24fa) SPrintf(sIdVersion, "[C++] VS2002 (.NET) build 9466");
    else if (idVersion == 0x004024fa) SPrintf(sIdVersion, "[ASM] VS2002 (.NET) build 9466");
    else if (idVersion == 0x003d24fa) SPrintf(sIdVersion, "[LNK] VS2002 (.NET) build 9466");
    else if (idVersion == 0x004524fa) SPrintf(sIdVersion, "[RES] VS2002 (.NET) build 9466");
    else if (idVersion == 0x003f24fa) SPrintf(sIdVersion, "[EXP] VS2002 (.NET) build 9466");
    else if (idVersion == 0x001924fa) SPrintf(sIdVersion, "[IMP] VS2002 (.NET) build 9466");
    else if (idVersion == 0x000a2636) SPrintf(sIdVersion, "[ C ] VS98 (6.0) SP6 build 8804");
    else if (idVersion == 0x000b2636) SPrintf(sIdVersion, "[C++] VS98 (6.0) SP6 build 8804");
    else if (idVersion == 0x00152306) SPrintf(sIdVersion, "[ C ] VC++ 6.0 SP5 build 8804");
    else if (idVersion == 0x00162306) SPrintf(sIdVersion, "[C++] VC++ 6.0 SP5 build 8804");
    else if (idVersion == 0x000420ff) SPrintf(sIdVersion, "[LNK] VC++ 6.0 SP5 imp/exp build 8447");
    else if (idVersion == 0x000606c7) SPrintf(sIdVersion, "[RES] VS98 (6.0) SP6 cvtres build 1736");
    else if (idVersion == 0x000a1fe8) SPrintf(sIdVersion, "[ C ] VS98 (6.0) build 8168");
    else if (idVersion == 0x000b1fe8) SPrintf(sIdVersion, "[C++] VS98 (6.0) build 8168");
    else if (idVersion == 0x000606b8) SPrintf(sIdVersion, "[RES] VS98 (6.0) cvtres build 1720");
    else if (idVersion == 0x00041fe8) SPrintf(sIdVersion, "[LNK] VS98 (6.0) imp/exp build 8168");
    else if (idVersion == 0x00060684) SPrintf(sIdVersion, "[RES] VS97 (5.0) SP3 cvtres 5.00.1668");
    else if (idVersion == 0x00021c87) SPrintf(sIdVersion, "[IMP] VS97 (5.0) SP3 link 5.10.7303");
    else
    {
        local WORD id = idVersion >> 0x10;
        local WORD version = idVersion & 0xffff;
        SPrintf(sIdVersion, "id: %d version: %d", id, version);
    }
    return sIdVersion;
}

string ReadRichEntryIdVersion(DWORD& idVersionEncoded)
{
    local DWORD idVersion = idVersionEncoded ^ DosStub.RichHeader.XorKey;
    local string sIdVersion = GetRichIdVersionString(idVersion);
    return sIdVersion;
}

string ReadRichEntryCount(DWORD& count)
{
    local DWORD v = count ^ DosStub.RichHeader.XorKey;
    local string s;
    SPrintf(s, "count: %d", v);
    return s;
}


/**** COMMMENT UTILITY FUNCTIONS ****/
string LocationRVA(ULONG ulRVA)
{
    local int i=0;

    for (i = 0; i < NtHeader.FileHeader.NumberOfSections; i++)
    {
        if ( (ulRVA >= SectionHeaders[i].VirtualAddress) && (ulRVA <= SectionHeaders[i].VirtualAddress + SectionHeaders[i].SizeOfRawData) )
        {
          return SectionHeaders[i].Name;
        }
    }
    return "";
}

string CommentRVA2FOA(DWORD dwRVA)
{
    local string sComment = "";
    if (0 != dwRVA)
    {
        SPrintf(sComment, "%s FOA = 0x%X \n", LocationRVA(dwRVA), RVA2FOA(dwRVA));
    }
    return sComment;
}

string CommentRVAString(DWORD dwRVA)
{
    local string sComment = "";
    if (0 != dwRVA)
    {
        SPrintf(sComment, "%s FOA = 0x%X -> %s", LocationRVA(dwRVA), RVA2FOA(dwRVA), ReadString(RVA2FOA(dwRVA)) );
    }
    return sComment;
}

string CommentImageImportByName(IMAGE_IMPORT_BY_NAME& ImportByName)
{
    return ImportByName.Name;
}

string CommentExportByName(IMAGE_EXPORT_BY_NAME& ExportByName)
{
    local string sComment = "";

    if (0 == Strlen(ExportByName.sLocalJmpName))
    {
        SPrintf(sComment, "0x%X", ExportByName.ulLocalDestRVA);
    }
    else
    {
        SPrintf(sComment, "%s", ExportByName.sLocalJmpName);
    }

    return sComment;
}

string CommentExportDirectory(IMAGE_EXPORT_DIRECTORY& ExportDir)
{
    return ReadString(RVA2FOA(ExportDir.Name));
}

string CommentBaseRelocBlock(BASE_RELOCATION_BLOCK& Block)
{
    switch (Block.Type)
    {
        case IMAGE_REL_BASED_ABSOLUTE:
            return "ABSOLUTE";
        case IMAGE_REL_BASED_HIGH:
            return "HIGH";
        case IMAGE_REL_BASED_LOW:
            return "LOW";
        case IMAGE_REL_BASED_HIGHLOW:
            return "HIGHLOW";
        case IMAGE_REL_BASED_HIGHADJ:
            return "HIGHADJ";
        case IMAGE_REL_BASED_RESERVED:
            return "RESERVED";
        case IMAGE_REL_BASED_DIR64:
            return "DIR64";
        default:
            return "UNKNOWN";
    }
}

string CommentImageBaseRelocation(IMAGE_BASE_RELOCATION& BaseReloc)
{
    local string sComment = "";
    SPrintf(sComment, "%d", BaseReloc.ulBlockNum);
    return sComment;
}

string CommentResourceNameOffset(DWORD& NameOffset)
{
    local DWORD   dwMaskedOffset = (NameOffset & 0x7fffffff);
    local wstring wsComment      = L"";
    local string  sComment       = "";
    local DWORD   loc            = RVA2FOA(NtHeader.OptionalHeader.DataDirArray.Resource.VirtualAddress) + dwMaskedOffset;
    local WORD    actualLength   = ReadUShort(loc);
    wsComment = ReadWString(loc + sizeof(WORD));
    wsComment = WSubStr(wsComment, 0, actualLength);
    sComment = WStringToString(wsComment);
    return sComment;
}

short GetNameEntries(RESOURCE_DIRECTORY_TABLE& ResourceDirectoryTable)
{
    return ResourceDirectoryTable.NumberOfNameEntries;
}

int GetLevel(RESOURCE_DIRECTORY_ENTRY& ResourceDirectoryEntry)
{
    return ResourceDirectoryEntry.Level;
}

string GetType(DWORD& IntegerID)
{
    local string sComment = "";

    if      (IntegerID == 0 || IntegerID > 255) SPrintf(sComment, "%d: Unknown",            IntegerID);
    else if (IntegerID == 1)                    SPrintf(sComment, "%d: RT_CURSOR",          IntegerID);
    else if (IntegerID == 2)                    SPrintf(sComment, "%d: RT_BITMAP",          IntegerID);
    else if (IntegerID == 3)                    SPrintf(sComment, "%d: RT_ICON",            IntegerID);
    else if (IntegerID == 4)                    SPrintf(sComment, "%d: RT_MENU",            IntegerID);
    else if (IntegerID == 5)                    SPrintf(sComment, "%d: RT_DIALOG",          IntegerID);
    else if (IntegerID == 6)                    SPrintf(sComment, "%d: RT_STRING",          IntegerID);
    else if (IntegerID == 7)                    SPrintf(sComment, "%d: RT_FONTDIR",         IntegerID);
    else if (IntegerID == 8)                    SPrintf(sComment, "%d: RT_FONT",            IntegerID);
    else if (IntegerID == 9)                    SPrintf(sComment, "%d: RT_ACCELERATOR",     IntegerID);
    else if (IntegerID == 10)                   SPrintf(sComment, "%d: RT_RCDATA",          IntegerID);
    else if (IntegerID == 11)                   SPrintf(sComment, "%d: RT_MESSAGETABLE",    IntegerID);
    else if (IntegerID == 12)                   SPrintf(sComment, "%d: RT_GROUP_CURSOR",    IntegerID);
    else if (IntegerID == 13)                   SPrintf(sComment, "%d: Reserved",           IntegerID);
    else if (IntegerID == 14)                   SPrintf(sComment, "%d: RT_GROUP_ICON",      IntegerID);
    else if (IntegerID == 15)                   SPrintf(sComment, "%d: Reserved",           IntegerID);
    else if (IntegerID == 16)                   SPrintf(sComment, "%d: RT_VERSION",         IntegerID);
    else if (IntegerID == 17)                   SPrintf(sComment, "%d: RT_DLGINCLUDE",      IntegerID);
    else if (IntegerID == 18)                   SPrintf(sComment, "%d: Reserved",           IntegerID);
    else if (IntegerID == 19)                   SPrintf(sComment, "%d: RT_PLUGPLAY",        IntegerID);
    else if (IntegerID == 20)                   SPrintf(sComment, "%d: RT_VXD",             IntegerID);
    else if (IntegerID == 21)                   SPrintf(sComment, "%d: RT_ANICURSOR",       IntegerID);
    else if (IntegerID == 22)                   SPrintf(sComment, "%d: RT_ANIICON",         IntegerID);
    else if (IntegerID == 23)                   SPrintf(sComment, "%d: RT_HTML",            IntegerID);
    else if (IntegerID == 24)                   SPrintf(sComment, "%d: RT_MANIFEST",        IntegerID);
    else if (IntegerID < 256)                   SPrintf(sComment, "%d: Reserved",           IntegerID);

    return sComment;
}

string CommentIntegerID(DWORD& IntegerID)
{
    local string sComment = "";
    local int level = GetLevel( parentof(IntegerID) );
    switch(level)
    {
        case 1:
            sComment = "Type (" + GetType(IntegerID) + ")";
            break;
        case 2:
            sComment = "";
            break;
        case 3:
            sComment = "Language";
            break;
        default:
            break;
    }

    return sComment;
}

string CommentResourceDirectoryString(RESOURCE_DIRECTORY_STRING& str)
{
    local string sComment = "";
    local DWORD loc = startof(str);
    local WORD actualLength = ReadShort(loc);
    local DWORD BlockNumber = GetEntryIntegerID( parentof(parentof(parentof(parentof(parentof(str))))) );
    local int myIndex = 0;
    local DWORD blockStart = startof(parentof(str));
    local DWORD curLoc = blockStart;
    while(curLoc != loc)
    {
        myIndex++;
        curLoc += 2*ReadUShort(curLoc)+sizeof(WORD);
    }
    local DWORD myStringID  = (BlockNumber-1)*16+myIndex;
    if (actualLength > 0)
    {
        local wstring wsComment = ReadWString(startof(str) + sizeof(WORD));
        wsComment = WSubStr(wsComment, 0, actualLength);
        SPrintf(sComment, "String ID #%d: %s", myStringID, WStringToString(wsComment));
    }
    else
    {
        SPrintf(sComment, "String ID #%d: <null>", myStringID);
    }
    return sComment;
}

string CommentResourceDirectoryTable(RESOURCE_DIRECTORY_TABLE& ResourceDirectoryTable)
{
    local string sComment = "";
    local DWORD totalEntries = ResourceDirectoryTable.NumberOfNameEntries + ResourceDirectoryTable.NumberOfIDEntries;

    if (totalEntries == 1)
    {
        SPrintf(sComment, "Level %d, %d entry", ResourceDirectoryTable.Level, totalEntries);
    }
    else
    {
        SPrintf(sComment, "Level %d, %d entries", ResourceDirectoryTable.Level, totalEntries);
    }

    return sComment;
}

int GetEntryIntegerID(RESOURCE_DIRECTORY_ENTRY& ResourceDirectoryEntry)
{
    return ResourceDirectoryEntry.IntegerID;
}

int GetEntryIsNameEntry(RESOURCE_DIRECTORY_ENTRY& ResourceDirectoryEntry)
{
    return ResourceDirectoryEntry.IsNameEntry;
}

int GetParentTableLevel(RESOURCE_DIRECTORY_TABLE& ResourceDirectoryTable)
{
    return ResourceDirectoryTable.Level;
}

int IsResourceDirectoryString(RESOURCE_DATA_ENTRY& ResourceDataEntry)
{
    local int ParentTableLevel = GetParentTableLevel( parentof(parentof(ResourceDataEntry)) );
    if (ParentTableLevel == 3)
    {
        local int BaseEntryIsNameEntry = GetEntryIsNameEntry(
            parentof(parentof(parentof(parentof(parentof(ResourceDataEntry))))));
        if (BaseEntryIsNameEntry == 0)
        {
            local int BaseEntryIntegerID = GetEntryIntegerID(
                parentof(parentof(parentof(parentof(parentof(ResourceDataEntry))))));
            if (BaseEntryIntegerID == 6)
            {
                return 1;
            }
        }
    }

    return 0;
}

string CommentBaseRelocationTable(BASE_RELOCATION_TABLE& RelocTable)
{
    local string sComment = "";
    SPrintf(sComment,"%d",RelocTable.ulRelocNum);
    return sComment;
}


/**** PARSING CODE ****/
LittleEndian();
Printf("EXE.bt Begin\n");

IMAGE_DOS_HEADER DosHeader;
if (DosHeader.MZSignature != 0x5A4D)
{
    Printf("Invalid DOS Magic.\n");
    return 1;
}
if (0 == DosHeader.AddressOfNewExeHeader)
{
    Warning("Invalid AddressOfNewExeHeader = 0x%X",DosHeader.AddressOfNewExeHeader);
    return 2;
}

if (sizeof(IMAGE_DOS_HEADER) < DosHeader.AddressOfNewExeHeader)
{
    IMAGE_DOS_STUB DosStub;
}
FSeek(DosHeader.AddressOfNewExeHeader);
IMAGE_NT_HEADERS NtHeader;
if (0x00004550 != NtHeader.Signature)
{
    Printf("Invalid NT Signature 0x%x\n",NtHeader.Signature);
    return 3;
}

IMAGE_SECTION_HEADER SectionHeaders[NtHeader.FileHeader.NumberOfSections];

// Unpadded header size
local ULONG ulRawHeaderSize = DosHeader.AddressOfNewExeHeader + sizeof(NtHeader) + NtHeader.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER);

local ULONG ulFirstSectionPointer = 0xffffffff;
local ULONG ulIndex;

for (ulIndex=0; ulIndex < NtHeader.FileHeader.NumberOfSections; ulIndex++)
{
    if ( 0 == SectionHeaders[ulIndex].PointerToRawData )
    {
        continue;
    }
    if ( 0 == SectionHeaders[ulIndex].SizeOfRawData )
    {
        continue;
    }
    if ( ulFirstSectionPointer > SectionHeaders[ulIndex].PointerToRawData )
    {
        ulFirstSectionPointer = SectionHeaders[ulIndex].PointerToRawData;
    }
}

if (ulFirstSectionPointer - ulRawHeaderSize > 0)
{
    UCHAR Space2[ulFirstSectionPointer - ulRawHeaderSize] <hidden=true,fgcolor=cRed,comment="Space between header and first section">;
    Printf("Space between header and first section is %d bytes\n", sizeof(Space2));
}

for (ulIndex=0; ulIndex < NtHeader.FileHeader.NumberOfSections; ulIndex++)
{
    if ( 0 == SectionHeaders[ulIndex].PointerToRawData )
    {
        continue;
    }
    if ( 0 == SectionHeaders[ulIndex].SizeOfRawData )
    {
        continue;
    }
    FSeek(SectionHeaders[ulIndex].PointerToRawData);
    IMAGE_SECTION_DATA Section(SectionHeaders[ulIndex]);
}

FSeek(NtHeader.OptionalHeader.SizeOfHeaders);

// Parse IMAGE_DIRECTORY_ENTRIES
ParseEAT();
ParseIAT();
ParseResource();
ParseException();
ParseSecurity();
ParseBaseReloc();
ParseDebug();
ParseTLS();
ParseBoundImport();
ParseDelayImport();

Printf("EXE.bt finished\n");
